//lib/l10n
//lib/l10n/app_am.arb
{
  "@@locale": "am",
  "appTitle": "መጂወ አስጠኚ",
  "home": "መነሻ",
  "library": "ቤተ-መጽሐፍት",
  "notifications": "ማሳወቂያዎች",
  "account": "መለያ",
  "aboutUs": "ስለ እኛ",
  "settings": "ቅንብሮች",
  "logout": "ውጣ",
  "changeLanguage": "ቋንቋ ቀይር",
  "english": "እንግሊዝኛ",
  "amharic": "አማርኛ",
  "tigrigna": "ትግርኛ",
  "afaanOromo": "አፋን ኦሮሞ",
  "welcomeMessage": "ወደ መጂወ አስጠኚ በደህና መጡ!",
  "testimonials": "ምስክርነት",
  "registerforcourses": "ለኮርስዎች ይመዝገቡ",
  "mycourses": "የኔ ኮርስዎች",
  "weeklyexam": "የሳምንቱ ፈተናዎች",
  "sharetheapp": "አፕሊኬሽኑን ይጋሩ",
  "joinourtelegram": "ቴሌግራማችንን ይቀላቀሉ",
  "discussiongroup": "ውይይት ቡድን",
  "contactus": "አግኙን",
  "refresh": "ማደሰ",
  "getRegisteredTitle": "ይመዝገቡ",
  "studentNameLabel": "የተማሪ ስም",
  "studentNameValidationError": "እባኮትን የተማሪ ስም ያስገቡ",
  "fatherNameLabel": "አባት ስም",
  "fatherNameValidationError": "እባኮትን የአባት ስም ያስገቡ",
  "streamLabel": "ዲፓርትመንት",
  "naturalStream": "ተፈጥሯዊ",
  "socialStream": "ማህበራዊ",
  "institutionLabel": "ተቋም",
  "selectInstitutionHint": "ተቋም ይምረጡ",
  "institutionValidationError": "እባኮትን ተቋም ይምረጡ",
  "genderLabel": "ጾታ",
  "maleGender": "ወንድ",
  "femaleGender": "ሴት",
  "selectServiceLabel": "የአገልግሎት ዓይነት ይምረጡ",
  "selectServiceHint": "የአገልግሎት ዓይነት ይምረጡ",
  "serviceValidationError": "እባኮትን የአገልግሎት ዓይነት ይምረጡ",
  "paymentInstruction": "በአጠቃላይ 200ETB ከሚከተሉት መለያዎች ወደ አንዱ ያስተላልፉ እና ከዚያ የማረጋገጫውን ቅጽበታዊ ገጽ እይታ ከዚህ በታች ያያይዙ።",
  "bankAccountLabel": "መለያ",
  "bankHolderNameLabel": "ስም",
  "copiedToClipboardMessage": "{accountNumber} ወደ ቅንጥብ ሰሌዳ ተቀድቷል!",
  "@copiedToClipboardMessage": {
    "placeholders": {
      "accountNumber": {
        "type": "String"
      }
    }
  },
  "attachScreenshotButton": "ቅጽበታዊ ገጽ እይታን ያያይዙ",
  "screenshotAttachedButton": "ቅጽበታዊ ገጽ እይታ ተያይዟል!",
  "fileNamePrefix": "ፋይል",
  "termsAndConditionsAgreement": "በመቀጠልዎ በውሎች እና ሁኔታዎች ተስማምተዋል ",
  "termsAndConditionsLink": "ውሎች እና ሁኔታዎች",
  "termsAndConditionsAnd": " እና ",
  "privacyPolicyLink": "የግላዊነት ፖሊሲ",
  "submitButton": "ይመዝገቡ",
  "errorPickingImage": "ምስልን መምረጥ ላይ ስህተት: {errorMessage}",
  "@errorPickingImage": {
    "placeholders": {
      "errorMessage": {
        "type": "String"
      }
    }
  },
  "pleaseSelectStreamError": "እባክዎ ዲፓርትመንት ይምረጡ።",
  "pleaseSelectInstitutionError": "እባክዎ ተቋም ይምረጡ።",
  "pleaseSelectGenderError": "እባክዎ ጾታዎን ይምረጡ።",
  "pleaseSelectServiceError": "እባክዎ የአገልግሎት ዓይነት ይምረጡ።",
  "pleaseAttachScreenshotError": "እባክዎ የክፍያ ቅጽበታዊ ገጽ ያያይዙ።",
  "pleaseAgreeToTermsError": "እባክዎ በደንቦቹ እና ሁኔታዎች ይስማሙ።",
  "notRegisteredTitle": "እስካሁን ያልተመዘገቡ ይመስላል።",
  "notRegisteredSubtitle": "ውጤቶቻችሁን ለማሳደግ የትምህርት ሀብቶቻችንን ለመመዝገብ እና ለማግኘት ቅጹን ይሙሉ።",
  "getRegisteredNowButton": "አሁን ይመዝገቡ",
  "mgwTutorialTitle": "መጂወ አስጠኚ",
  "signUpToStartLearning": "መማር ለመጀመር ይመዝገቡ",
  "signUpTitle": "መለያ ይፍጠሩ",
  "createAccountButton": "መለያ ይፍጠሩ",
  "alreadyHaveAccount": "አስቀድመው መለያ አለዎት?",
  "signInLink": "ይግቡ",
  "signUpSuccessMessage": "መለያ በተሳካ ሁኔታ ተፈጥሯል! አሁን መግባት ይችላሉ።",
  "signUpFailedErrorGeneral": "መለያ መፍጠር አልተሳካም። እባክዎ እንደገና ይሞክሩ።",
  "loginTitle": "ይግቡ",
  "loginToContinue": "የመማር ጉዞዎን ለመቀጠል ይግቡ።",
  "signInButton": "ይግቡ",
  "dontHaveAccount": "መለያ የሎትም?",
  "signUpLinkText": "አሁን ይመዝገቡ",
  "phoneNumberLabel": "ስልክ ቁጥር",
  "phoneNumberHint": "912 345 678",
  "phoneNumberValidationErrorRequired": "እባክዎ ስልክ ቁጥርዎን ያስገቡ",
  "phoneNumberValidationErrorInvalid": "ትክክለኛ ባለ 9 አሃዝ ስልክ ቁጥር ያስገቡ",
  "passwordLabel": "የይለፍ ቃል",
  "passwordHint": "የይለፍ ቃልዎን ያስገቡ",
  "passwordValidationErrorRequired": "እባክዎ የይለፍ ቃልዎን ያስገቡ",
  "passwordValidationErrorLength": "የይለፍ ቃል ቢያንስ 6 ቁምፊዎች መሆን አለበት",
  "accountCreationSimulatedMessage": "የአካውንት አፈጣጠር ተመስሏል። ኮንሶሉን ያረጋግጡ።",
  "loginSuccessMessage": "በተሳካ ሁኔታ ገብተዋል! እንኳን ደህና መጡ።",
  "signInFailedErrorGeneral": "መግባት አልተሳካም። እባክዎ መረጃዎን ያረጋግጡና እንደገና ይሞክሩ።",
  "changeProfilePictureButton": "የመገለጫ ፎቶ ቀይር",
  "profilePictureSelectedMessage": "የመገለጫ ፎቶ ተመርጧል! (አልተሰቀለም)",
  "accountPhoneNumberLabel": "ስልክ ቁጥር",
  "changePhoneNumberNotImplementedMessage": "ስልክ ቁጥር ለመቀየር ተነክቷል (አልተተገበረም)",
  "accountPasswordLabel": "የይለፍ ቃል",
  "changePasswordNotImplementedMessage": "የይለፍ ቃል ለመቀየር ተነክቷል (አልተተገበረም)",
  "notificationsLabel": "ማሳወቂያዎች",
  "notificationsEnabledMessage": "ማሳወቂያዎች ነቅተዋል",
  "notificationsDisabledMessage": "ማሳወቂያዎች ቆመዋል",
  "changeButton": "ቀይር",

  "phoneNumberCannotBeEmptyError": "ስልክ ቁጥር ባዶ መሆን አይችልም።",
  "invalidPhoneNumberFormatError": "የማያገለግል የስልክ ቁጥር ዓይነት። እባክዎ 09...፣ 9...፣ ወይም +2519... ይጠቀሙ።",
  "registrationSuccessMessage": "ምዝገባው ተሳክቷል! እባክዎ የአስተዳዳሪ ማረጋገጫ ይጠብቁ።",
  "registrationFailedDefaultMessage": "ምዝገባ አልተሳካም። እባክዎ እንደገና ይሞክሩ።",
  "selectDepartmentHint": "ዲፓርትመንት / የትምህርት መስክ ይምረጡ",
  "yearLabel": "ዓመት / ክፍል",
  "yearValidationErrorEmpty": "እባክዎ ዓመት ያስገቡ።",
  "yearValidationErrorInvalid": "እባክዎ ትክክለኛ ዓመት ያስገቡ።",
    "departmentLabel": "ዲፓርትመንት",
  "selectDepartmentHint": "ዲፓርትመንት ይምረጡ",
  "pleaseSelectDepartmentError": "እባክዎ ዲፓርትመንት ይምረጡ።",
  "yearLabel": "የትምህርት ዘመን",
  "selectYearHint": "ዓመት ይምረጡ",
  "pleaseSelectYearError": "እባክዎ የትምህርት ዘመንዎን ይምረጡ።",
    "guestUser": "እንግዳ ተጠቃሚ",
  "pleaseLoginOrRegister": "እባክዎ ይግቡ ወይም ይመዝገቡ",
  "registeredUser": "የተመዘገበ ተጠቃሚ",
  "logoutSuccess": "በተሳካ ሁኔታ ወጥተዋል።",
   "selectSemesterLabel": "ሴሚስተር ይምረጡ", 
  "selectSemesterHint": "ሴሚስተር ይምረጡ", 
  "pleaseSelectSemesterError": "እባክዎ ሴሚስተር ይምረጡ።"
  
}
//lib/l10n/app_en.arb
{
  "@@locale": "en",
  "appTitle": "MGW Tutorial",
  "home": "Home",
  "library": "Library",
  "notifications": "Notifications",
  "account": "Account",
  "aboutUs": "About Us",
  "settings": "Settings",
  "logout": "Logout",
  "changeLanguage": "Change Language",
  "english": "English",
  "amharic": "Amharic",
  "tigrigna": "Tigrigna",
  "afaanOromo": "Afaan Oromo",
  "welcomeMessage": "Welcome to MGW Tutorial!",
  "testimonials" : "Testimonials",
  "registerforcourses": "Register for courses",
  "mycourses": "My Courses",
  "weeklyexam": "Weekly Exams",
  "sharetheapp": "Share the App",
  "joinourtelegram": "Join our Telegram",
  "discussiongroup": "Discussion Group",
  "contactus": "Contact Us",
  "refresh": "Refresh",
  "getRegisteredTitle": "Get Registered",
  "studentNameLabel": "Student's Name",
  "studentNameValidationError": "Please enter student's name",
  "fatherNameLabel": "Father's Name",
  "fatherNameValidationError": "Please enter father's name",
  "streamLabel": "Department",
  "naturalStream": "Natural",
  "socialStream": "Social",
  "institutionLabel": "Institution",
  "selectInstitutionHint": "Select Institution",
  "institutionValidationError": "Please select institution",
  "genderLabel": "Gender",
  "maleGender": "Male",
  "femaleGender": "Female",
  "selectServiceLabel": "Select Service",
  "selectServiceHint": "Select Service",
  "serviceValidationError": "Please select a service",
  "paymentInstruction": "Transfer a total of 200ETB to one of the following accounts and then attach a screenshot of the confirmation below.",
  "bankAccountLabel": "Account",
  "bankHolderNameLabel": "Name",
  "copiedToClipboardMessage": "{accountNumber} copied to clipboard!",
  "@copiedToClipboardMessage": {
    "placeholders": {
      "accountNumber": {
        "type": "String"
      }
    }
  },
  "attachScreenshotButton": "Attach Screenshot",
  "screenshotAttachedButton": "Screenshot Attached!",
  "fileNamePrefix": "File",
  "termsAndConditionsAgreement": "By continuing you are agreeing to the ",
  "termsAndConditionsLink": "terms and condition",
  "termsAndConditionsAnd": " and ",
  "privacyPolicyLink": "privacy policy",
  "submitButton": "Get Registered",
  "errorPickingImage": "Error picking image: {errorMessage}",
  "@errorPickingImage": {
    "placeholders": {
      "errorMessage": {
        "type": "String"
      }
    }
  },
  "pleaseSelectStreamError": "Please select a Department.",
  "pleaseSelectInstitutionError": "Please select an institution.",
  "pleaseSelectGenderError": "Please select your gender.",
  "pleaseSelectServiceError": "Please select a service.",
  "pleaseAttachScreenshotError": "Please attach a payment screenshot.",
  "pleaseAgreeToTermsError": "Please agree to the terms and conditions.",
  "notRegisteredTitle": "Looks like you're not registered yet",
  "notRegisteredSubtitle": "Fill out the form to register and access our educational resources to boost your grades.",
  "getRegisteredNowButton": "Get Registered Now",
  "mgwTutorialTitle": "MGW Tutorial",
  "signUpToStartLearning": "Sign up to start learning",
  "signUpTitle": "Create Account",
  "createAccountButton": "Create Account",
  "alreadyHaveAccount": "Already have an account?",
  "signInLink": "Sign In",
  "signUpSuccessMessage": "Account created successfully! You can now sign in.",
  "signUpFailedErrorGeneral": "Sign up failed. Please try again.",
  "loginTitle": "Sign In",
  "loginToContinue": "Sign in to continue your learning journey.",
  "signInButton": "Sign In",
  "dontHaveAccount": "Don't have an account?",
  "signUpLinkText": "Sign Up Now",
  "phoneNumberLabel": "Phone Number",
  "phoneNumberHint": "912 345 678",
  "phoneNumberValidationErrorRequired": "Please enter your phone number",
  "phoneNumberValidationErrorInvalid": "Enter a valid 9-digit phone number",
  "passwordLabel": "Password",
  "passwordHint": "Enter your password",
  "passwordValidationErrorRequired": "Please enter your password",
  "passwordValidationErrorLength": "Password must be at least 6 characters",
  "accountCreationSimulatedMessage": "Account creation simulated. Check console.",
  "loginSuccessMessage": "Login successful! Welcome back.",
  "signInFailedErrorGeneral": "Sign in failed. Please check your credentials and try again.",
  "changeProfilePictureButton": "Change Profile Picture",
  "profilePictureSelectedMessage": "Profile picture selected! (Not Uploaded)",
  "accountPhoneNumberLabel": "Phone number",
  "changePhoneNumberNotImplementedMessage": "Change Phone Number Tapped (Not Implemented)",
  "accountPasswordLabel": "Password",
  "changePasswordNotImplementedMessage": "Change Password Tapped (Not Implemented)",
  "notificationsLabel": "Notifications",
  "notificationsEnabledMessage": "Notifications Enabled",
  "notificationsDisabledMessage": "Notifications Disabled",
  "changeButton": "Change",

  "phoneNumberCannotBeEmptyError": "Phone number cannot be empty.",
  "invalidPhoneNumberFormatError": "Invalid phone number format. Use 09..., 9..., or +2519...",
  "registrationSuccessMessage": "Registration successful! Please await admin approval.",
  "registrationFailedDefaultMessage": "Registration failed. Please try again.",
  "selectDepartmentHint": "Select Department / Stream",
  "yearLabel": "Year / Grade",
  "yearValidationErrorEmpty": "Please enter year.",
  "yearValidationErrorInvalid": "Please enter a valid year.",
  "departmentLabel": "Department",
  "selectDepartmentHint": "Select Department",
  "pleaseSelectDepartmentError": "Please select a department.",
  "yearLabel": "Academic Year",
  "selectYearHint": "Select Year",
  "pleaseSelectYearError": "Please select your academic year.",
    "guestUser": "Guest User",
  "pleaseLoginOrRegister": "Please login or register",
  "registeredUser": "Registered User",
  "logoutSuccess": "Logged out successfully.",
   "selectSemesterLabel": "Select Semester", 
  "selectSemesterHint": "Select a Semester", 
  "pleaseSelectSemesterError": "Please select a semester."
}
//lib/l10n/app_or.arb
{
  "@@locale": "or",
  "appTitle": "መጂወ አስጠኚ",
  "home": "መነሻ",
  "library": "ቤተ-መጽሐፍት",
  "notifications": "ማሳወቂያዎች",
  "account": "መለያ",
  "aboutUs": "ስለ እኛ",
  "settings": "ቅንብሮች",
  "logout": "ውጣ",
  "changeLanguage": "ቋንቋ ቀይር",
  "english": "እንግሊዝኛ",
  "amharic": "አማርኛ",
  "tigrigna": "ትግርኛ",
  "afaanOromo": "አፋን ኦሮሞ",
  "welcomeMessage": "ወደ መጂወ አስጠኚ በደህና መጡ!",
  "testimonials": "ምስክርነት",
  "registerforcourses": "ለኮርስዎች ይመዝገቡ",
  "mycourses": "የኔ ኮርስዎች",
  "weeklyexam": "የሳምንቱ ፈተናዎች",
  "sharetheapp": "አፕሊኬሽኑን ይጋሩ",
  "joinourtelegram": "ቴሌግራማችንን ይቀላቀሉ",
  "discussiongroup": "ውይይት ቡድን",
  "contactus": "አግኙን",
  "refresh": "ማደሰ",
  "getRegisteredTitle": "ይመዝገቡ",
  "studentNameLabel": "የተማሪ ስም",
  "studentNameValidationError": "እባኮትን የተማሪ ስም ያስገቡ",
  "fatherNameLabel": "አባት ስም",
  "fatherNameValidationError": "እባኮትን የአባት ስም ያስገቡ",
  "streamLabel": "ዲፓርትመንት",
  "naturalStream": "ተፈጥሯዊ",
  "socialStream": "ማህበራዊ",
  "institutionLabel": "ተቋም",
  "selectInstitutionHint": "ተቋም ይምረጡ",
  "institutionValidationError": "እባኮትን ተቋም ይምረጡ",
  "genderLabel": "ጾታ",
  "maleGender": "ወንድ",
  "femaleGender": "ሴት",
  "selectServiceLabel": "የአገልግሎት ዓይነት ይምረጡ",
  "selectServiceHint": "የአገልግሎት ዓይነት ይምረጡ",
  "serviceValidationError": "እባኮትን የአገልግሎት ዓይነት ይምረጡ",
  "paymentInstruction": "በአጠቃላይ 200ETB ከሚከተሉት መለያዎች ወደ አንዱ ያስተላልፉ እና ከዚያ የማረጋገጫውን ቅጽበታዊ ገጽ እይታ ከዚህ በታች ያያይዙ።",
  "bankAccountLabel": "መለያ",
  "bankHolderNameLabel": "ስም",
  "copiedToClipboardMessage": "{accountNumber} ወደ ቅንጥብ ሰሌዳ ተቀድቷል!",
  "@copiedToClipboardMessage": {
    "placeholders": {
      "accountNumber": {
        "type": "String"
      }
    }
  },
  "attachScreenshotButton": "ቅጽበታዊ ገጽ እይታን ያያይዙ",
  "screenshotAttachedButton": "ቅጽበታዊ ገጽ እይታ ተያይዟል!",
  "fileNamePrefix": "ፋይል",
  "termsAndConditionsAgreement": "በመቀጠልዎ በውሎች እና ሁኔታዎች ተስማምተዋል ",
  "termsAndConditionsLink": "ውሎች እና ሁኔታዎች",
  "termsAndConditionsAnd": " እና ",
  "privacyPolicyLink": "የግላዊነት ፖሊሲ",
  "submitButton": "ይመዝገቡ",
  "errorPickingImage": "ምስልን መምረጥ ላይ ስህተት: {errorMessage}",
  "@errorPickingImage": {
    "placeholders": {
      "errorMessage": {
        "type": "String"
      }
    }
  },
  "pleaseSelectStreamError": "እባክዎ ዲፓርትመንት ይምረጡ።",
  "pleaseSelectInstitutionError": "እባክዎ ተቋም ይምረጡ።",
  "pleaseSelectGenderError": "እባክዎ ጾታዎን ይምረጡ።",
  "pleaseSelectServiceError": "እባክዎ የአገልግሎት ዓይነት ይምረጡ።",
  "pleaseAttachScreenshotError": "እባክዎ የክፍያ ቅጽበታዊ ገጽ ያያይዙ።",
  "pleaseAgreeToTermsError": "እባክዎ በደንቦቹ እና ሁኔታዎች ይስማሙ።",
  "notRegisteredTitle": "እስካሁን ያልተመዘገቡ ይመስላል።",
  "notRegisteredSubtitle": "ውጤቶቻችሁን ለማሳደግ የትምህርት ሀብቶቻችንን ለመመዝገብ እና ለማግኘት ቅጹን ይሙሉ።",
  "getRegisteredNowButton": "አሁን ይመዝገቡ",
  "mgwTutorialTitle": "መጂወ አስጠኚ",
  "signUpToStartLearning": "መማር ለመጀመር ይመዝገቡ",
  "signUpTitle": "መለያ ይፍጠሩ",
  "createAccountButton": "መለያ ይፍጠሩ",
  "alreadyHaveAccount": "አስቀድመው መለያ አለዎት?",
  "signInLink": "ይግቡ",
  "signUpSuccessMessage": "መለያ በተሳካ ሁኔታ ተፈጥሯል! አሁን መግባት ይችላሉ።",
  "signUpFailedErrorGeneral": "መለያ መፍጠር አልተሳካም። እባክዎ እንደገና ይሞክሩ።",
  "loginTitle": "ይግቡ",
  "loginToContinue": "የመማር ጉዞዎን ለመቀጠል ይግቡ።",
  "signInButton": "ይግቡ",
  "dontHaveAccount": "መለያ የሎትም?",
  "signUpLinkText": "አሁን ይመዝገቡ",
  "phoneNumberLabel": "ስልክ ቁጥር",
  "phoneNumberHint": "912 345 678",
  "phoneNumberValidationErrorRequired": "እባክዎ ስልክ ቁጥርዎን ያስገቡ",
  "phoneNumberValidationErrorInvalid": "ትክክለኛ ባለ 9 አሃዝ ስልክ ቁጥር ያስገቡ",
  "passwordLabel": "የይለፍ ቃል",
  "passwordHint": "የይለፍ ቃልዎን ያስገቡ",
  "passwordValidationErrorRequired": "እባክዎ የይለፍ ቃልዎን ያስገቡ",
  "passwordValidationErrorLength": "የይለፍ ቃል ቢያንስ 6 ቁምፊዎች መሆን አለበት",
  "accountCreationSimulatedMessage": "የአካውንት አፈጣጠር ተመስሏል። ኮንሶሉን ያረጋግጡ።",
  "loginSuccessMessage": "በተሳካ ሁኔታ ገብተዋል! እንኳን ደህና መጡ።",
  "signInFailedErrorGeneral": "መግባት አልተሳካም። እባክዎ መረጃዎን ያረጋግጡና እንደገና ይሞክሩ።",
  "changeProfilePictureButton": "የመገለጫ ፎቶ ቀይር",
  "profilePictureSelectedMessage": "የመገለጫ ፎቶ ተመርጧል! (አልተሰቀለም)",
  "accountPhoneNumberLabel": "ስልክ ቁጥር",
  "changePhoneNumberNotImplementedMessage": "ስልክ ቁጥር ለመቀየር ተነክቷል (አልተተገበረም)",
  "accountPasswordLabel": "የይለፍ ቃል",
  "changePasswordNotImplementedMessage": "የይለፍ ቃል ለመቀየር ተነክቷል (አልተተገበረም)",
  "notificationsLabel": "ማሳወቂያዎች",
  "notificationsEnabledMessage": "ማሳወቂያዎች ነቅተዋል",
  "notificationsDisabledMessage": "ማሳወቂያዎች ቆመዋል",
  "changeButton": "ቀይር",

  "phoneNumberCannotBeEmptyError": "ስልክ ቁጥር ባዶ መሆን አይችልም።",
  "invalidPhoneNumberFormatError": "የማያገለግል የስልክ ቁጥር ዓይነት። እባክዎ 09...፣ 9...፣ ወይም +2519... ይጠቀሙ።",
  "registrationSuccessMessage": "ምዝገባው ተሳክቷል! እባክዎ የአስተዳዳሪ ማረጋገጫ ይጠብቁ።",
  "registrationFailedDefaultMessage": "ምዝገባ አልተሳካም። እባክዎ እንደገና ይሞክሩ።",
  "selectDepartmentHint": "ዲፓርትመንት / የትምህርት መስክ ይምረጡ",
  "yearLabel": "ዓመት / ክፍል",
  "yearValidationErrorEmpty": "እባክዎ ዓመት ያስገቡ።",
  "yearValidationErrorInvalid": "እባክዎ ትክክለኛ ዓመት ያስገቡ።",
    "departmentLabel": "ዲፓርትመንት",
  "selectDepartmentHint": "ዲፓርትመንት ይምረጡ",
  "pleaseSelectDepartmentError": "እባክዎ ዲፓርትመንት ይምረጡ።",
  "yearLabel": "የትምህርት ዘመን",
  "selectYearHint": "ዓመት ይምረጡ",
  "pleaseSelectYearError": "እባክዎ የትምህርት ዘመንዎን ይምረጡ።",
    "guestUser": "እንግዳ ተጠቃሚ",
  "pleaseLoginOrRegister": "እባክዎ ይግቡ ወይም ይመዝገቡ",
  "registeredUser": "የተመዘገበ ተጠቃሚ",
  "logoutSuccess": "በተሳካ ሁኔታ ወጥተዋል።",
  "selectSemesterLabel": "ሴሚስተር ይምረጡ", 
  "selectSemesterHint": "ሴሚስተር ይምረጡ", 
  "pleaseSelectSemesterError": "እባክዎ ሴሚስተር ይምረጡ።"
}
//lib/l10n/app_ti.arb
{
  "@@locale": "ti",
  "appTitle": "መጂወ አስጠኚ",
  "home": "መነሻ",
  "library": "ቤተ-መጽሐፍት",
  "notifications": "ማሳወቂያዎች",
  "account": "መለያ",
  "aboutUs": "ስለ እኛ",
  "settings": "ቅንብሮች",
  "logout": "ውጣ",
  "changeLanguage": "ቋንቋ ቀይር",
  "english": "እንግሊዝኛ",
  "amharic": "አማርኛ",
  "tigrigna": "ትግርኛ",
  "afaanOromo": "አፋን ኦሮሞ",
  "welcomeMessage": "ወደ መጂወ አስጠኚ በደህና መጡ!",
  "testimonials": "ምስክርነት",
  "registerforcourses": "ለኮርስዎች ይመዝገቡ",
  "mycourses": "የኔ ኮርስዎች",
  "weeklyexam": "የሳምንቱ ፈተናዎች",
  "sharetheapp": "አፕሊኬሽኑን ይጋሩ",
  "joinourtelegram": "ቴሌግራማችንን ይቀላቀሉ",
  "discussiongroup": "ውይይት ቡድን",
  "contactus": "አግኙን",
  "refresh": "ማደሰ",
  "getRegisteredTitle": "ይመዝገቡ",
  "studentNameLabel": "የተማሪ ስም",
  "studentNameValidationError": "እባኮትን የተማሪ ስም ያስገቡ",
  "fatherNameLabel": "አባት ስም",
  "fatherNameValidationError": "እባኮትን የአባት ስም ያስገቡ",
  "streamLabel": "ዲፓርትመንት",
  "naturalStream": "ተፈጥሯዊ",
  "socialStream": "ማህበራዊ",
  "institutionLabel": "ተቋም",
  "selectInstitutionHint": "ተቋም ይምረጡ",
  "institutionValidationError": "እባኮትን ተቋም ይምረጡ",
  "genderLabel": "ጾታ",
  "maleGender": "ወንድ",
  "femaleGender": "ሴት",
  "selectServiceLabel": "የአገልግሎት ዓይነት ይምረጡ",
  "selectServiceHint": "የአገልግሎት ዓይነት ይምረጡ",
  "serviceValidationError": "እባኮትን የአገልግሎት ዓይነት ይምረጡ",
  "paymentInstruction": "በአጠቃላይ 200ETB ከሚከተሉት መለያዎች ወደ አንዱ ያስተላልፉ እና ከዚያ የማረጋገጫውን ቅጽበታዊ ገጽ እይታ ከዚህ በታች ያያይዙ።",
  "bankAccountLabel": "መለያ",
  "bankHolderNameLabel": "ስም",
  "copiedToClipboardMessage": "{accountNumber} ወደ ቅንጥብ ሰሌዳ ተቀድቷል!",
  "@copiedToClipboardMessage": {
    "placeholders": {
      "accountNumber": {
        "type": "String"
      }
    }
  },
  "attachScreenshotButton": "ቅጽበታዊ ገጽ እይታን ያያይዙ",
  "screenshotAttachedButton": "ቅጽበታዊ ገጽ እይታ ተያይዟል!",
  "fileNamePrefix": "ፋይል",
  "termsAndConditionsAgreement": "በመቀጠልዎ በውሎች እና ሁኔታዎች ተስማምተዋል ",
  "termsAndConditionsLink": "ውሎች እና ሁኔታዎች",
  "termsAndConditionsAnd": " እና ",
  "privacyPolicyLink": "የግላዊነት ፖሊሲ",
  "submitButton": "ይመዝገቡ",
  "errorPickingImage": "ምስልን መምረጥ ላይ ስህተት: {errorMessage}",
  "@errorPickingImage": {
    "placeholders": {
      "errorMessage": {
        "type": "String"
      }
    }
  },
  "pleaseSelectStreamError": "እባክዎ ዲፓርትመንት ይምረጡ።",
  "pleaseSelectInstitutionError": "እባክዎ ተቋም ይምረጡ።",
  "pleaseSelectGenderError": "እባክዎ ጾታዎን ይምረጡ።",
  "pleaseSelectServiceError": "እባክዎ የአገልግሎት ዓይነት ይምረጡ።",
  "pleaseAttachScreenshotError": "እባክዎ የክፍያ ቅጽበታዊ ገጽ ያያይዙ።",
  "pleaseAgreeToTermsError": "እባክዎ በደንቦቹ እና ሁኔታዎች ይስማሙ።",
  "notRegisteredTitle": "እስካሁን ያልተመዘገቡ ይመስላል።",
  "notRegisteredSubtitle": "ውጤቶቻችሁን ለማሳደግ የትምህርት ሀብቶቻችንን ለመመዝገብ እና ለማግኘት ቅጹን ይሙሉ።",
  "getRegisteredNowButton": "አሁን ይመዝገቡ",
  "mgwTutorialTitle": "መጂወ አስጠኚ",
  "signUpToStartLearning": "መማር ለመጀመር ይመዝገቡ",
  "signUpTitle": "መለያ ይፍጠሩ",
  "createAccountButton": "መለያ ይፍጠሩ",
  "alreadyHaveAccount": "አስቀድመው መለያ አለዎት?",
  "signInLink": "ይግቡ",
  "signUpSuccessMessage": "መለያ በተሳካ ሁኔታ ተፈጥሯል! አሁን መግባት ይችላሉ።",
  "signUpFailedErrorGeneral": "መለያ መፍጠር አልተሳካም። እባክዎ እንደገና ይሞክሩ።",
  "loginTitle": "ይግቡ",
  "loginToContinue": "የመማር ጉዞዎን ለመቀጠል ይግቡ።",
  "signInButton": "ይግቡ",
  "dontHaveAccount": "መለያ የሎትም?",
  "signUpLinkText": "አሁን ይመዝገቡ",
  "phoneNumberLabel": "ስልክ ቁጥር",
  "phoneNumberHint": "912 345 678",
  "phoneNumberValidationErrorRequired": "እባክዎ ስልክ ቁጥርዎን ያስገቡ",
  "phoneNumberValidationErrorInvalid": "ትክክለኛ ባለ 9 አሃዝ ስልክ ቁጥር ያስገቡ",
  "passwordLabel": "የይለፍ ቃል",
  "passwordHint": "የይለፍ ቃልዎን ያስገቡ",
  "passwordValidationErrorRequired": "እባክዎ የይለፍ ቃልዎን ያስገቡ",
  "passwordValidationErrorLength": "የይለፍ ቃል ቢያንስ 6 ቁምፊዎች መሆን አለበት",
  "accountCreationSimulatedMessage": "የአካውንት አፈጣጠር ተመስሏል። ኮንሶሉን ያረጋግጡ።",
  "loginSuccessMessage": "በተሳካ ሁኔታ ገብተዋል! እንኳን ደህና መጡ።",
  "signInFailedErrorGeneral": "መግባት አልተሳካም። እባክዎ መረጃዎን ያረጋግጡና እንደገና ይሞክሩ።",
  "changeProfilePictureButton": "የመገለጫ ፎቶ ቀይር",
  "profilePictureSelectedMessage": "የመገለጫ ፎቶ ተመርጧል! (አልተሰቀለም)",
  "accountPhoneNumberLabel": "ስልክ ቁጥር",
  "changePhoneNumberNotImplementedMessage": "ስልክ ቁጥር ለመቀየር ተነክቷል (አልተተገበረም)",
  "accountPasswordLabel": "የይለፍ ቃል",
  "changePasswordNotImplementedMessage": "የይለፍ ቃል ለመቀየር ተነክቷል (አልተተገበረም)",
  "notificationsLabel": "ማሳወቂያዎች",
  "notificationsEnabledMessage": "ማሳወቂያዎች ነቅተዋል",
  "notificationsDisabledMessage": "ማሳወቂያዎች ቆመዋል",
  "changeButton": "ቀይር",

  "phoneNumberCannotBeEmptyError": "ስልክ ቁጥር ባዶ መሆን አይችልም።",
  "invalidPhoneNumberFormatError": "የማያገለግል የስልክ ቁጥር ዓይነት። እባክዎ 09...፣ 9...፣ ወይም +2519... ይጠቀሙ።",
  "registrationSuccessMessage": "ምዝገባው ተሳክቷል! እባክዎ የአስተዳዳሪ ማረጋገጫ ይጠብቁ።",
  "registrationFailedDefaultMessage": "ምዝገባ አልተሳካም። እባክዎ እንደገና ይሞክሩ።",
  "selectDepartmentHint": "ዲፓርትመንት / የትምህርት መስክ ይምረጡ",
  "yearLabel": "ዓመት / ክፍል",
  "yearValidationErrorEmpty": "እባክዎ ዓመት ያስገቡ።",
  "yearValidationErrorInvalid": "እባክዎ ትክክለኛ ዓመት ያስገቡ።",
    "departmentLabel": "ዲፓርትመንት",
  "selectDepartmentHint": "ዲፓርትመንት ይምረጡ",
  "pleaseSelectDepartmentError": "እባክዎ ዲፓርትመንት ይምረጡ።",
  "yearLabel": "የትምህርት ዘመን",
  "selectYearHint": "ዓመት ይምረጡ",
  "pleaseSelectYearError": "እባክዎ የትምህርት ዘመንዎን ይምረጡ።",
    "guestUser": "እንግዳ ተጠቃሚ",
  "pleaseLoginOrRegister": "እባክዎ ይግቡ ወይም ይመዝገቡ",
  "registeredUser": "የተመዘገበ ተጠቃሚ",
  "logoutSuccess": "በተሳካ ሁኔታ ወጥተዋል።"
}

--------------------
//lib/models

// lib/models/api_course.dart
import 'dart:convert';

class CourseCategoryInfo {
  final int id;
  final String name; // API has "catagory"

  CourseCategoryInfo({required this.id, required this.name});

  factory CourseCategoryInfo.fromJson(Map<String, dynamic> json) {
    return CourseCategoryInfo(
      id: json['id'] as int? ?? 0,
      name: json['catagory'] as String? ?? 'Unknown Category', // API uses "catagory"
    );
  }
}

class ApiCourse {
  final int id;
  final String title;
  final String? shortDescription;
  final String? description;
  final List<String> outcomes;
  final String? language;
  final int? categoryId;
  final String? section; // API shows "10", might be string or int
  final List<String> requirements;
  final String price;
  final bool? discountFlag;
  final String? discountedPrice;
  final String? thumbnail; // e.g., "uploads/uee.jpg"
  final String? videoUrl;
  final bool? isTopCourse;
  final String status;
  final bool? isVideoCourse; // API has "video": "false" (string)
  final bool? isFreeCourse;
  final bool? multiInstructor;
  final String? creator;
  final DateTime createdAt;
  final DateTime updatedAt;
  final CourseCategoryInfo? category;

  // Base URL for thumbnails - This should ideally be configurable
  static const String thumbnailBaseUrl = "https://courseservice.zsecreteducation.com/";


  ApiCourse({
    required this.id,
    required this.title,
    this.shortDescription,
    this.description,
    required this.outcomes,
    this.language,
    this.categoryId,
    this.section,
    required this.requirements,
    required this.price,
    this.discountFlag,
    this.discountedPrice,
    this.thumbnail,
    this.videoUrl,
    this.isTopCourse,
    required this.status,
    this.isVideoCourse,
    this.isFreeCourse,
    this.multiInstructor,
    this.creator,
    required this.createdAt,
    required this.updatedAt,
    this.category,
  });

  String? get fullThumbnailUrl {
    if (thumbnail != null && thumbnail!.isNotEmpty) {
      if (thumbnail!.toLowerCase().startsWith('http')) {
        return thumbnail; // It's already a full URL
      }
      return thumbnailBaseUrl + thumbnail!;
    }
    return null;
  }

  factory ApiCourse.fromJson(Map<String, dynamic> json) {
    // Helper to parse string lists like "[]" or "[\"item1\", \"item2\"]"
    List<String> parseStringList(dynamic jsonField) {
      if (jsonField is String) {
        try {
          final decoded = jsonDecode(jsonField);
          if (decoded is List) {
            return decoded.map((item) => item.toString()).toList();
          }
        } catch (e) {
          // If not a valid JSON string, or not a list, return empty or handle as needed
          print("Could not parse string list: $jsonField, error: $e");
        }
      } else if (jsonField is List) {
        return jsonField.map((item) => item.toString()).toList();
      }
      return [];
    }
    
    bool? parseBoolFromString(dynamic value) {
        if (value is bool) return value;
        if (value is String) return value.toLowerCase() == 'true';
        return null;
    }

    return ApiCourse(
      id: json['id'] as int,
      title: json['title'] as String? ?? 'Untitled Course',
      shortDescription: json['short_description'] as String?,
      description: json['description'] as String?,
      outcomes: parseStringList(json['outcomes']),
      language: json['language'] as String?,
      categoryId: json['category_id'] as int?,
      section: json['section']?.toString(), // API sends "10" (string)
      requirements: parseStringList(json['requirements']),
      price: json['price'] as String? ?? "0.00",
      discountFlag: json['discount_flag'] as bool?,
      discountedPrice: json['discounted_price'] as String?,
      thumbnail: json['thumbnail'] as String?,
      videoUrl: json['video_url'] as String?,
      isTopCourse: json['is_top_course'] as bool?,
      status: json['status'] as String? ?? 'unknown',
      isVideoCourse: parseBoolFromString(json['video']), // API sends "false" as string
      isFreeCourse: json['is_free_course'] as bool?,
      multiInstructor: json['multi_instructor'] as bool?,
      creator: json['creator'] as String?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      category: json['category'] != null
          ? CourseCategoryInfo.fromJson(json['category'] as Map<String, dynamic>)
          : null,
    );
  }
}
// lib/models/api_error.dart
import 'package:mgw_tutorial/models/field_error.dart'; // We'll import FieldError here
import 'package:mgw_tutorial/models/field_error.dart';
class ApiError {
  final String message;
  final List<FieldError>? errors;

  ApiError({required this.message, this.errors});

  factory ApiError.fromJson(Map<String, dynamic> json) {
    var errorsList = json['errors'] as List<dynamic>?;
    List<FieldError>? fieldErrors;
    if (errorsList != null) {
      fieldErrors = errorsList.map((e) => FieldError.fromJson(e as Map<String, dynamic>)).toList();
    }
    return ApiError(
      message: json['message'] as String? ?? 'An unknown error occurred.',
      errors: fieldErrors,
    );
  }
}
// lib/models/auth_response.dart
import 'package:mgw_tutorial/models/user.dart'; // Ensure this path is correct

class AuthResponse {
  final User user;
  final String? token; // Token is nullable because the API doesn't send it yet

  AuthResponse({
    required this.user,
    this.token, // Token is optional in the constructor
  });

  factory AuthResponse.fromJson(Map<String, dynamic> json) {
    
    return AuthResponse(
      user: User.fromJson(json['user'] as Map<String, dynamic>),
      
      token: json['token'] as String?,
    );
  }
}
// lib/models/author.dart
class Author {
  final int id;
  final String name;

  Author({
    required this.id,
    required this.name,
  });

  // Helper function to safely extract and cast int values
  static int _safeGetInt(Map<String, dynamic> json, String key, String modelName) {
    final value = json[key];
    if (value == null) {
      throw FormatException("Field '$key' is null in $modelName JSON, expected int. JSON: $json");
    }
    if (value is String) { // Try to parse if it's a string
        final parsedValue = int.tryParse(value);
        if (parsedValue != null) return parsedValue;
        throw FormatException("Field '$key' is a String that cannot be parsed to int in $modelName JSON. Value: '$value'. JSON: $json");
    }
    if (value is! int) {
      throw FormatException("Field '$key' is not an int in $modelName JSON, expected int but got ${value.runtimeType}. JSON: $json");
    }
    return value;
  }

  static String _safeGetString(Map<String, dynamic> json, String key, String modelName) {
    final value = json[key];
    if (value == null) {
      throw FormatException("Field '$key' is null in $modelName JSON, expected String. JSON: $json");
    }
    if (value is! String) {
      throw FormatException("Field '$key' is not a String in $modelName JSON, expected String but got ${value.runtimeType}. JSON: $json");
    }
    return value;
  }

  factory Author.fromJson(Map<String, dynamic> json) {
    return Author(
      id: _safeGetInt(json, 'id', 'Author'), // Use the helper
      name: _safeGetString(json, 'name', 'Author'),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
    };
  }
}
// lib/models/comment.dart
import 'package:mgw_tutorial/models/author.dart';
import 'package:mgw_tutorial/models/reply.dart';

class CommentPostInfo {
  final int id;
  final String title;

  CommentPostInfo({required this.id, required this.title});

  factory CommentPostInfo.fromJson(Map<String, dynamic> json) {
    return CommentPostInfo(
      id: json['id'] as int? ?? 0,
      title: json['title'] as String? ?? 'Unknown Post',
    );
  }

  Map<String, dynamic> toJson() => {'id': id, 'title': title};
}

class Comment {
  final int id;
  final String comment; // This Dart field name can remain 'comment'
  final int userId;
  final int postId;
  final DateTime createdAt;
  final DateTime updatedAt;
  final Author author;
  final CommentPostInfo? post;

  final List<Reply> replies;
  final int replyCount;
  final bool isLoadingReplies;
  final bool areAllRepliesLoaded;

  Comment({
    required this.id,
    required this.comment,
    required this.userId,
    required this.postId,
    required this.createdAt,
    required this.updatedAt,
    required this.author,
    this.post,
    this.replies = const [],
    this.replyCount = 0,
    this.isLoadingReplies = false,
    this.areAllRepliesLoaded = false,
  });

  static String _safeGetString(Map<String, dynamic> json, String key, String modelName) {
    final value = json[key];
    if (value == null) {
      // Include the full JSON in the error for better debugging
      throw FormatException("Field '$key' is null in $modelName JSON, expected String. JSON: $json");
    }
    if (value is! String) {
      // Include the full JSON in the error
      throw FormatException("Field '$key' is not a String in $modelName JSON, expected String but got ${value.runtimeType}. JSON: $json");
    }
    return value;
  }

  factory Comment.fromJson(Map<String, dynamic> json) {
    List<Reply> nestedReplies = [];
    if (json['replies'] != null && json['replies'] is List) {
      nestedReplies = (json['replies'] as List)
          .map((replyJson) => Reply.fromJson(replyJson as Map<String, dynamic>))
          .toList();
    }

    final authorJson = json['author'];
    if (authorJson == null || authorJson is! Map<String, dynamic>) {
        throw FormatException("Field 'author' is missing, null, or not a map in Comment JSON. JSON: $json");
    }

    return Comment(
      id: json['id'] as int,
      // THE FIX IS HERE: Read from 'content' key from JSON
      comment: _safeGetString(json, 'content', 'Comment'), // <--- MODIFIED
      userId: json['userId'] as int,
      postId: json['postId'] as int,
      createdAt: DateTime.parse(_safeGetString(json, 'createdAt', 'Comment')),
      updatedAt: DateTime.parse(_safeGetString(json, 'updatedAt', 'Comment')),
      author: Author.fromJson(authorJson),
      post: json['post'] != null ? CommentPostInfo.fromJson(json['post'] as Map<String, dynamic>) : null,
      replies: nestedReplies,
      replyCount: json['_count']?['replies'] as int? ?? (json['replies'] as List?)?.length ?? json['replyCount'] as int? ?? 0,
      isLoadingReplies: json['isLoadingReplies'] as bool? ?? false,
      areAllRepliesLoaded: json['areAllRepliesLoaded'] as bool? ?? (json['replies'] != null && (json['replies'] as List).isNotEmpty),
    );
  }

  Comment copyWith({
    int? id,
    String? comment,
    int? userId,
    int? postId,
    DateTime? createdAt,
    DateTime? updatedAt,
    Author? author,
    CommentPostInfo? post,
    List<Reply>? replies,
    int? replyCount,
    bool? isLoadingReplies,
    bool? areAllRepliesLoaded,
  }) {
    return Comment(
      id: id ?? this.id,
      comment: comment ?? this.comment,
      userId: userId ?? this.userId,
      postId: postId ?? this.postId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      author: author ?? this.author,
      post: post ?? this.post,
      replies: replies ?? this.replies,
      replyCount: replyCount ?? this.replyCount,
      isLoadingReplies: isLoadingReplies ?? this.isLoadingReplies,
      areAllRepliesLoaded: areAllRepliesLoaded ?? this.areAllRepliesLoaded,
    );
  }

  Map<String, dynamic> toJsonForCreate() {
    // This sends 'comment' to the backend. If your backend expects 'content' for creation,
    // you'd change 'comment': comment to 'content': comment here.
    // Based on your CommentProvider, it seems the backend expects 'comment' for create/update.
    return {
      'comment': comment,
      'userId': userId,
      'postId': postId,
    };
  }

  Map<String, dynamic> toJsonForUpdate() {
    // Similarly, if backend expects 'content' for update, change key here.
     return {
      'comment': comment,
    };
  }
}
// lib/models/department.dart

class Department {
  final int id;
  final String name;
  final DateTime createdAt;
  final DateTime updatedAt;

  Department({
    required this.id,
    required this.name,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Department.fromJson(Map<String, dynamic> json) {
    return Department(
      id: json['id'] as int,
      name: json['name'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );
  }

  // Optional: For debugging or if you need to compare objects
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Department && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'Department(id: $id, name: $name)';
  }
}
// lib/models/field_error.dart

class FieldError {
  final String field;
  final String message;

  FieldError({
    required this.field,
    required this.message,
  });

  factory FieldError.fromJson(Map<String, dynamic> json) {
    return FieldError(
      field: json['field'] as String? ?? 'unknown_field',
      message: json['message'] as String? ?? 'No specific error message for this field.',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'field': field,
      'message': message,
    };
  }
}
// lib/models/lesson.dart

enum LessonType { video, document, quiz, text, unknown }
enum AttachmentType { youtube, vimeo, file, url, unknown }

class Lesson {
  final int id;
  final String title; // Potential culprit if API sends null
  final int sectionId;
  final String? summary;
  final int? order;

  final String? videoProvider;
  final String? videoUrl;

  final String? attachmentUrl;
  final String? attachmentTypeString;

  final String? lessonTypeString;
  final String? duration;
  final DateTime createdAt; // Potential culprit if API sends null
  final DateTime updatedAt; // Potential culprit if API sends null

  Lesson({
    required this.id,
    required this.title,
    required this.sectionId,
    this.summary,
    this.order,
    this.videoProvider,
    this.videoUrl,
    this.attachmentUrl,
    this.attachmentTypeString,
    this.lessonTypeString,
    this.duration,
    required this.createdAt,
    required this.updatedAt,
  });

  LessonType get lessonType {
    switch (lessonTypeString?.toLowerCase()) {
      case 'video': return LessonType.video;
      case 'document': case 'pdf': case 'article': return LessonType.document;
      case 'quiz': case 'exam': return LessonType.quiz;
      case 'text': return LessonType.text;
      default: return LessonType.unknown;
    }
  }

  AttachmentType get attachmentType {
     switch (attachmentTypeString?.toLowerCase()) {
      case 'youtube': return AttachmentType.youtube;
      case 'vimeo': return AttachmentType.vimeo;
      case 'file': case 'pdf': case 'image': case 'doc': return AttachmentType.file;
      case 'url': return AttachmentType.url;
      default:
        if (videoUrl != null && videoUrl!.isNotEmpty) {
          if (videoProvider?.toLowerCase() == 'youtube') return AttachmentType.youtube;
          if (videoProvider?.toLowerCase() == 'vimeo') return AttachmentType.vimeo;
        }
        return AttachmentType.unknown;
    }
  }

  factory Lesson.fromJson(Map<String, dynamic> json) {
    // Helper to safely get a string, providing a default if null or not a string
    String safeGetString(Map<String, dynamic> jsonMap, String key, {String defaultValue = ""}) {
      final value = jsonMap[key];
      if (value is String) {
        return value;
      }
      // If you expect it to sometimes be a number and want to convert:
      // if (value is num) { return value.toString(); }
      if (value != null) { // It's not null but also not a string
          print("Warning: Field '$key' in Lesson JSON was not a String (type: ${value.runtimeType}). Using its toString() or default. JSON: $jsonMap");
          return value.toString(); // Attempt to convert if not null but wrong type
      }
      print("Warning: Field '$key' in Lesson JSON was null. Using default: '$defaultValue'. JSON: $jsonMap");
      return defaultValue;
    }
    
    // Helper for nullable strings (returns null if key is missing or value is null)
    String? safeGetNullableString(Map<String, dynamic> jsonMap, String key) {
        final value = jsonMap[key];
        if (value is String) {
            return value;
        }
        if (value != null) { // Not null but not a string
             print("Warning: Nullable field '$key' in Lesson JSON was not a String (type: ${value.runtimeType}). Using its toString(). JSON: $jsonMap");
             return value.toString();
        }
        return null; // If value is null or key is missing
    }


    // Helper for robust date parsing
    DateTime parseSafeDate(dynamic dateValue, String fieldName) {
      if (dateValue is String && dateValue.isNotEmpty) {
        try {
          return DateTime.parse(dateValue);
        } catch (e) {
          print("Error parsing date for Lesson field '$fieldName': $dateValue. Error: $e. Using current time as fallback.");
          return DateTime.now();
        }
      }
      print("Warning: Date field '$fieldName' in Lesson JSON was null or not a valid string. Using current time as fallback. Value: $dateValue");
      return DateTime.now();
    }

    // Helper for safe int parsing
    int safeGetInt(dynamic value, String fieldName, {int defaultValue = 0}) {
      if (value is int) {
        return value;
      }
      if (value is String) {
        final parsed = int.tryParse(value);
        if (parsed != null) return parsed;
      }
      print("Warning: Integer field '$fieldName' in Lesson JSON was not int or parsable string. Using default: '$defaultValue'. Value: $value");
      return defaultValue;
    }
    
    int? safeGetNullableInt(dynamic value, String fieldName) {
      if (value == null) return null;
      if (value is int) return value;
      if (value is String) return int.tryParse(value);
      print("Warning: Nullable integer field '$fieldName' in Lesson JSON was not int or parsable string. Returning null. Value: $value");
      return null;
    }


    return Lesson(
      id: safeGetInt(json['id'], 'id'),
      title: safeGetString(json, 'title', defaultValue: 'Untitled Lesson'), // SAFELY GET STRING
      sectionId: safeGetInt(json['section_id'], 'section_id'), // Assuming API sends this and it's required
      
      summary: safeGetNullableString(json, 'summary'),
      order: safeGetNullableInt(json['order'], 'order'),
      
      videoProvider: safeGetNullableString(json, 'video_provider') ?? safeGetNullableString(json, 'video_type'),
      videoUrl: safeGetNullableString(json, 'video_url'),
      
      attachmentUrl: safeGetNullableString(json, 'attachment'),
      attachmentTypeString: safeGetNullableString(json, 'attachment_type'),
      
      lessonTypeString: safeGetNullableString(json, 'lesson_type'),
      duration: safeGetNullableString(json, 'duration'),
      
      createdAt: parseSafeDate(json['created_at'], 'created_at'), // SAFELY PARSE DATE
      updatedAt: parseSafeDate(json['updated_at'], 'updated_at'), // SAFELY PARSE DATE
    );
  }
}
// lib/models/order.dart
import 'dart:convert';

// Renamed and generalized from OrderCategory
class OrderSelectionItem {
  final String id; // e.g., Semester ID
  final String name; // e.g., Semester Name

  OrderSelectionItem({
    required this.id,
    required this.name,
  });

  Map<String, dynamic> toJson() {
    // The API for orders expects "catagory" for the name field in its stringified JSON
    return {
      'id': id,
      'catagory': name, // Keep 'catagory' to match the existing order API
    };
  }

  factory OrderSelectionItem.fromJson(Map<String, dynamic> json) {
    return OrderSelectionItem(
      id: json['id'] as String,
      name: json['catagory'] as String, // Reads 'catagory' from API
    );
  }
}

class Order {
  final int? id;
  final String fullName;
  final String? bankName;
  final String phone;
  final String type; // Will be "department"
  final String status;
  // This 'categories' field in the Order model will now hold selected semesters (or other items)
  // and will be stringified from a List<OrderSelectionItem>
  final List<OrderSelectionItem> selections; // Renamed from 'categories' for clarity in the model
  final List<dynamic> courses;
  final String? screenshot;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  Order({
    this.id,
    required this.fullName,
    this.bankName,
    required this.phone,
    required this.type,
    required this.status,
    required this.selections, // Changed from categories
    this.courses = const [],
    this.screenshot,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, dynamic> toJsonForApi() {
    return {
      'full_name': fullName,
      'bank_name': bankName ?? "N/A",
      'phone': phone,
      'type': type, // This will be "department"
      'status': status,
      // The API's 'categories' field receives the stringified 'selections'
      'categories': jsonEncode(selections.map((sel) => sel.toJson()).toList()),
      'courses': jsonEncode(courses),
     // 'screenshot': screenshot,
    };
  }

  factory Order.fromJson(Map<String, dynamic> json) {
    List<OrderSelectionItem> parsedSelections = [];
    if (json['categories'] != null && json['categories'] is String) { // API uses 'categories'
      try {
        List<dynamic> sels = jsonDecode(json['categories']);
        parsedSelections = sels.map((s) => OrderSelectionItem.fromJson(s as Map<String, dynamic>)).toList();
      } catch (e) {
        print("Error parsing selections (categories) from order: $e");
      }
    }
    // ... (rest of fromJson for courses, etc. remains similar)
     List<dynamic> parsedCourses = [];
     if (json['courses'] != null && json['courses'] is String) {
      try {
        parsedCourses = jsonDecode(json['courses']);
      } catch (e) {
        print("Error parsing courses from order: $e");
      }
    }

    return Order(
      id: json['id'] as int?,
      fullName: json['full_name'] as String,
      bankName: json['bank_name'] as String?,
      phone: json['phone'] as String,
      type: json['type'] as String,
      status: json['status'] as String,
      selections: parsedSelections, // Use parsed selections
      courses: parsedCourses,
      screenshot: json['screenshot'] as String?,
      createdAt: json['createdAt'] != null ? DateTime.parse(json['createdAt'] as String) : null,
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt'] as String) : null,
    );
  }
}
// lib/models/post.dart
import 'package:mgw_tutorial/models/author.dart';
import 'package:mgw_tutorial/models/comment.dart'; // Though comments list is not populated here

class Post {
  final int id;
  final String title;
  final String description;
  final int userId;
  final DateTime createdAt;
  final DateTime updatedAt;
  final Author author;
  final List<Comment> comments;

  Post({
    required this.id,
    required this.title,
    required this.description,
    required this.userId,
    required this.createdAt,
    required this.updatedAt,
    required this.author,
    this.comments = const [],
  });
  
  static String _safeGetString(Map<String, dynamic> json, String key, String modelName) {
    final value = json[key];
    if (value == null) {
      throw FormatException("Field '$key' is null in $modelName JSON, expected String. JSON: $json");
    }
    if (value is! String) {
      throw FormatException("Field '$key' is not a String in $modelName JSON, expected String but got ${value.runtimeType}. JSON: $json");
    }
    return value;
  }

  factory Post.fromJson(Map<String, dynamic> json) {
    final authorJson = json['author'];
    if (authorJson == null || authorJson is! Map<String, dynamic>) {
        throw FormatException("Field 'author' is missing, null, or not a map in Post JSON. JSON: $json");
    }

    return Post(
      id: json['id'] as int,
      title: _safeGetString(json, 'title', 'Post'),
      description: _safeGetString(json, 'description', 'Post'),
      userId: json['userId'] as int,
      createdAt: DateTime.parse(_safeGetString(json, 'createdAt', 'Post')),
      updatedAt: DateTime.parse(_safeGetString(json, 'updatedAt', 'Post')),
      author: Author.fromJson(authorJson),
      // Comments are usually fetched separately
    );
  }
  // copyWith and toJson methods remain the same
   Post copyWith({
    int? id,
    String? title,
    String? description,
    int? userId,
    DateTime? createdAt,
    DateTime? updatedAt,
    Author? author,
    List<Comment>? comments,
  }) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      userId: userId ?? this.userId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      author: author ?? this.author,
      comments: comments ?? this.comments,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'userId': userId,
    };
  }
}
// lib/models/reply.dart
import 'package:mgw_tutorial/models/author.dart'; // Ensure Author model is correctly imported

// Definition for ParentCommentInfo (information about the comment a reply belongs to)
class ParentCommentInfo {
  final int id;
  // You could add other fields here if your API provides them for the parent comment context,
  // e.g., String? contentSnippet, Author? parentAuthor.
  // For now, just the ID is assumed.

  ParentCommentInfo({required this.id});

  factory ParentCommentInfo.fromJson(Map<String, dynamic> json) {
    final idValue = json['id'];
    if (idValue == null) {
      throw FormatException("Field 'id' is null in ParentCommentInfo JSON. JSON: $json");
    }
    if (idValue is String) {
      final parsedValue = int.tryParse(idValue);
      if (parsedValue != null) return ParentCommentInfo(id: parsedValue);
      throw FormatException("Field 'id' is a String that cannot be parsed to int in ParentCommentInfo JSON. Value: '$idValue'. JSON: $json");
    }
    if (idValue is! int) {
      throw FormatException("Field 'id' is not an int in ParentCommentInfo JSON. Got ${idValue.runtimeType}. JSON: $json");
    }
    return ParentCommentInfo(id: idValue);
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
    };
  }
}


class Reply {
  final int id;
  final String content;
  final int userId;
  final int commentId; // This will store the ID of the parent comment
  final DateTime createdAt;
  final DateTime updatedAt;
  final Author author;
  final ParentCommentInfo? parentComment; // Optional: Info about the direct parent comment object if provided

  Reply({
    required this.id,
    required this.content,
    required this.userId,
    required this.commentId, // This is the ID of the comment it's replying to
    required this.createdAt,
    required this.updatedAt,
    required this.author,
    this.parentComment,
  });

  static int _safeGetInt(Map<String, dynamic> json, String key, String modelName) {
    final value = json[key];
    if (value == null) {
      throw FormatException("Field '$key' is null in $modelName JSON, expected int. JSON: $json");
    }
    if (value is String) {
        final parsedValue = int.tryParse(value);
        if (parsedValue != null) return parsedValue;
        throw FormatException("Field '$key' is a String that cannot be parsed to int in $modelName JSON. Value: '$value'. JSON: $json");
    }
    if (value is! int) {
      throw FormatException("Field '$key' is not an int in $modelName JSON, expected int but got ${value.runtimeType}. JSON: $json");
    }
    return value;
  }

  static String _safeGetString(Map<String, dynamic> json, String key, String modelName) {
    final value = json[key];
    if (value == null) {
      throw FormatException("Field '$key' is null in $modelName JSON, expected String. JSON: $json");
    }
    if (value is! String) {
      throw FormatException("Field '$key' is not a String in $modelName JSON, expected String but got ${value.runtimeType}. JSON: $json");
    }
    return value;
  }

  factory Reply.fromJson(Map<String, dynamic> json) {
    final authorJson = json['author'];
    if (authorJson == null || authorJson is! Map<String, dynamic>) {
        throw FormatException("Field 'author' is missing, null, or not a map in Reply JSON. JSON: $json");
    }

    int parentCommentIdValue = _safeGetInt(json, 'postCommentId', 'Reply (for parent comment ID)');

    ParentCommentInfo? parentCommentInfoObject;
    final parentPostCommentJson = json['parentPostComment'];
    if (parentPostCommentJson != null && parentPostCommentJson is Map<String, dynamic>) {
        try {
            parentCommentInfoObject = ParentCommentInfo.fromJson(parentPostCommentJson);
        } catch (e) {
            print("Warning: Could not parse 'parentPostComment' object in Reply JSON: $e. JSON: $json");
        }
    } else if (parentPostCommentJson != null) {
        print("Warning: 'parentPostComment' in Reply JSON was expected to be an object but was ${parentPostCommentJson.runtimeType}. JSON: $json");
    }
    
    if (parentCommentInfoObject == null) {
        parentCommentInfoObject = ParentCommentInfo(id: parentCommentIdValue);
    }

    return Reply(
      id: _safeGetInt(json, 'id', 'Reply'),
      content: _safeGetString(json, 'content', 'Reply'),
      userId: _safeGetInt(json, 'userId', 'Reply'),
      commentId: parentCommentIdValue,
      createdAt: DateTime.parse(_safeGetString(json, 'createdAt', 'Reply')),
      updatedAt: DateTime.parse(_safeGetString(json, 'updatedAt', 'Reply')),
      author: Author.fromJson(authorJson),
      parentComment: parentCommentInfoObject,
    );
  }

  Reply copyWith({
    int? id,
    String? content,
    int? userId,
    int? commentId,
    DateTime? createdAt,
    DateTime? updatedAt,
    Author? author,
    ParentCommentInfo? parentComment,
  }) {
    return Reply(
      id: id ?? this.id,
      content: content ?? this.content,
      userId: userId ?? this.userId,
      commentId: commentId ?? this.commentId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      author: author ?? this.author,
      parentComment: parentComment ?? this.parentComment,
    );
  }

  Map<String, dynamic> toJsonForCreate() {
    return {
      'content': content,
      'userId': userId,
    };
  }

  Map<String, dynamic> toJsonForUpdate() {
    return {
      'content': content,
    };
  }
}
// lib/models/section.dart

class Section {
  final int id;
  final String title; // This is likely the culprit if API sends null for title
  final int courseId;
  final int? order;
  final DateTime createdAt;
  final DateTime updatedAt;

  Section({
    required this.id,
    required this.title,
    required this.courseId,
    this.order,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Section.fromJson(Map<String, dynamic> json) {
    // Helper to safely get a string, providing a default if null
    String safeGetString(Map<String, dynamic> jsonMap, String key, {String defaultValue = ""}) {
      final value = jsonMap[key];
      if (value is String) {
        return value;
      }
      // If you expect it to sometimes be a number and want to convert:
      // if (value is num) {
      //   return value.toString();
      // }
      print("Warning: Field '$key' in Section JSON was null or not a String. Using default: '$defaultValue'. JSON: $jsonMap");
      return defaultValue;
    }

    // Helper for robust date parsing
    DateTime parseSafeDate(dynamic dateValue, String fieldName) {
      if (dateValue is String && dateValue.isNotEmpty) {
        try {
          return DateTime.parse(dateValue);
        } catch (e) {
          print("Error parsing date for Section field '$fieldName': $dateValue. Error: $e. Using current time as fallback.");
          return DateTime.now();
        }
      }
      print("Warning: Date field '$fieldName' in Section JSON was null or not a valid string. Using current time as fallback. Value: $dateValue");
      return DateTime.now();
    }
    
    // Helper for safe int parsing (can also handle strings if needed)
    int safeGetInt(dynamic value, String fieldName, {int defaultValue = 0}) {
      if (value is int) {
        return value;
      }
      if (value is String) {
        return int.tryParse(value) ?? defaultValue;
      }
      print("Warning: Integer field '$fieldName' in Section JSON was not int or string. Using default: '$defaultValue'. Value: $value");
      return defaultValue;
    }


    return Section(
      id: safeGetInt(json['id'], 'id'), // Use helper or ensure 'id' is never null
      title: safeGetString(json, 'title', defaultValue: 'Untitled Section'), // SAFELY GET STRING
      courseId: safeGetInt(json['course_id'], 'course_id'), // Ensure 'course_id' is never null or handle it
      order: json['order'] as int?, // 'order' is already nullable in the model, so `as int?` is okay if API might omit it
      createdAt: parseSafeDate(json['created_at'], 'created_at'), // SAFELY PARSE DATE
      updatedAt: parseSafeDate(json['updated_at'], 'updated_at'), // SAFELY PARSE DATE
    );
  }
}
// lib/models/semester.dart
import 'package:flutter/foundation.dart';

// Assuming Course model is defined as previously:
class Course {
  final String name;
  Course({required this.name});
  factory Course.fromJson(dynamic json) {
    if (json is String) return Course(name: json);
    if (json is Map<String, dynamic>) return Course(name: json['name'] as String? ?? 'Unnamed Course');
    return Course(name: 'Invalid Course Data');
  }
  Map<String, dynamic> toJson() => {'name': name}; // For completeness
  @override
  String toString() => name;
}

class Semester {
  final int id;
  final String name;
  final String year;
  final String price;
  final List<String> images;
  final List<Course> courses;
  final DateTime createdAt;
  final DateTime updatedAt;

  Semester({
    required this.id,
    required this.name,
    required this.year,
    required this.price,
    required this.images,
    required this.courses,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Semester.fromJson(Map<String, dynamic> json) {
    var imageList = (json['images'] as List<dynamic>?)
            ?.map((e) => e.toString()) // Use .toString() for safety if items might not be strings
            .toList() ??
        [];
    var courseListRaw = json['courses'] as List<dynamic>? ?? [];
    List<Course> parsedCourses =
        courseListRaw.map((courseData) => Course.fromJson(courseData)).toList();

    return Semester(
      id: json['id'] as int? ?? 0, // Default if null
      name: json['name'] as String? ?? 'Unnamed Semester',
      year: json['year'] as String? ?? 'N/A',
      price: json['price'] as String? ?? '0.00',
      images: imageList,
      courses: parsedCourses,
      createdAt: json['createdAt'] != null && (json['createdAt'] as String).isNotEmpty
          ? DateTime.parse(json['createdAt'] as String)
          : DateTime.fromMillisecondsSinceEpoch(0), // Default to epoch or a known placeholder
      updatedAt: json['updatedAt'] != null && (json['updatedAt'] as String).isNotEmpty
          ? DateTime.parse(json['updatedAt'] as String)
          : DateTime.fromMillisecondsSinceEpoch(0), // Default to epoch
    );
  }

  String? get firstImageUrl {
    if (images.isNotEmpty) {
      if (images.first.startsWith('/')) {
        return "https://mgw-backend-1.onrender.com${images.first}";
      }
      return images.first;
    }
    return null;
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'year': year,
      'price': price,
      'images': images,
      'courses': courses.map((e) => e.toJson()).toList(),
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }

  @override
  String toString() {
    return 'Semester(id: $id, name: $name, year: $year, price: $price, images: ${images.length}, courses: ${courses.length})';
  }
}
// lib/models/testimonial.dart
import 'package:mgw_tutorial/models/author.dart'; // We'll reuse the Author model

class Testimonial {
  final int id;
  final String title; // New: from your API
  final String description; // New: from your API (was 'text')
  final int userId; // New: from your API
  final String status; // New: from your API
  final List<String> images; // New: from your API
  final DateTime createdAt;
  final DateTime updatedAt; // New: from your API
  final Author author; // New: from your API

  // Base URL for images - This should ideally be configurable or come from a central place
  static const String imageBaseUrl = "https://mgw-backend.onrender.com";


  Testimonial({
    required this.id,
    required this.title,
    required this.description,
    required this.userId,
    required this.status,
    required this.images,
    required this.createdAt,
    required this.updatedAt,
    required this.author,
  });

  String? get firstFullImageUrl {
    if (images.isNotEmpty) {
      final firstImage = images.first;
      if (firstImage.startsWith('http')) {
        return firstImage; // Already a full URL
      }
      if (firstImage.startsWith('/')) { // Path like /uploads/image.jpg
        return imageBaseUrl + firstImage;
      }
      // If it's just a filename, you might need a different prefix logic
      // For now, assume it starts with '/' if not absolute
    }
    return null;
  }

  factory Testimonial.fromJson(Map<String, dynamic> json) {
    // Helper for robust date parsing
    DateTime parseSafeDate(String? dateString) {
      if (dateString == null || dateString.isEmpty) {
        return DateTime.now(); // Fallback or throw error
      }
      try {
        return DateTime.parse(dateString);
      } catch (e) {
        print("Error parsing date for testimonial: $dateString. Error: $e");
        return DateTime.now(); // Fallback
      }
    }
    
    List<String> parseImages(dynamic imageList) {
        if (imageList is List) {
            return imageList.map((e) => e.toString()).toList();
        }
        return [];
    }


    final authorJson = json['author'];
    if (authorJson == null || authorJson is! Map<String, dynamic>) {
      throw FormatException("Field 'author' is missing or not a map in Testimonial JSON: $json");
    }

    return Testimonial(
      id: json['id'] as int,
      title: json['title'] as String? ?? 'Untitled Testimonial',
      description: json['description'] as String? ?? 'No description provided.',
      userId: json['userId'] as int? ?? 0,
      status: json['status'] as String? ?? 'unknown',
      images: parseImages(json['images']),
      createdAt: parseSafeDate(json['createdAt'] as String?),
      updatedAt: parseSafeDate(json['updatedAt'] as String?),
      author: Author.fromJson(authorJson),
    );
  }
}
// lib/models/user.dart

class User {
  // Fields from GET /api/users and Registration Form
  final int? id;
  String firstName;
  String lastName;
  String phone;
  String? password;
  bool? allCourses; // API: "all_coures"
  String? grade;
  String? category;
  String? school;
  String? gender;
  String? region;
  String? status;
  bool? enrolledAll;
  String? device; // This will now be used in login as well
  DateTime? createdAt;
  DateTime? updatedAt;
  String? serviceType;

  User({
    this.id,
    required this.firstName,
    required this.lastName,
    required this.phone,
    this.password,
    this.allCourses,
    this.grade,
    this.category,
    this.school,
    this.gender,
    this.region,
    this.status,
    this.enrolledAll,
    this.device, // Added to constructor parameters
    this.createdAt,
    this.updatedAt,
    this.serviceType,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as int?,
      firstName: json['first_name'] as String? ?? '',
      lastName: json['last_name'] as String? ?? '',
      phone: json['phone'] as String? ?? '',
      allCourses: json['all_coures'] as bool?, // API typo "all_coures"
      grade: json['grade'] as String?,
      category: json['category'] as String?,
      school: json['school'] as String?,
      gender: json['gender'] as String?,
      region: json['region'] as String?,
      status: json['status'] as String?,
      enrolledAll: json['enrolled_all'] as bool?,
      device: json['device'] as String?,
      createdAt: json['createdAt'] == null ? null : DateTime.tryParse(json['createdAt'].toString()),
      updatedAt: json['updatedAt'] == null ? null : DateTime.tryParse(json['updatedAt'].toString()),
      // serviceType is not typically part of the main user object from /api/users
      // It's used during registration and might be part of a more detailed user profile endpoint.
    );
  }

  Map<String, dynamic> toJsonForFullRegistration() {
    return {
      "first_name": firstName,
      "last_name": lastName,
      "phone": phone,
      "password": password,
      "all_coures": allCourses ?? false, // API typo
      "grade": grade,
      "category": category,
      "school": school,
      "gender": gender,
      "region": region ?? "Not Specified",
      "status": status ?? "pending",
      "enrolled_all": enrolledAll ?? false,
      "device": device,
      "serviceType": serviceType, // Include if your /api/users endpoint accepts this
    };
  }

  Map<String, dynamic> toJsonForLogin() {
    return {
      "phone": phone,
      "password": password,
      "device": device, // <<< MODIFIED: Added device field
    };
  }

  Map<String, dynamic> toJsonForSimpleSignUp() {
    // Ensure this matches what your simple sign-up endpoint expects
    return {
      "phone": phone, // Or "phoneNumber" if API expects that
      "password": password,
      "firstName": firstName, // If simple signup also takes names
      "lastName": lastName,
      // "language": "en", // Example, or dynamically set if needed
      "device": device, // It's good practice to send device on signup too
    };
  }
}

----------------------------
//lib/providers


// lib/provider/api_course_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/api_course.dart';

class ApiCourseProvider with ChangeNotifier {
  List<ApiCourse> _courses = []; // This list will be used for the "semester" dropdown
  bool _isLoading = false;
  String? _error;

  List<ApiCourse> get courses => [..._courses];
  bool get isLoading => _isLoading;
  String? get error => _error;

  // UPDATED API Base URL and endpoint logic
  static const String _apiBaseUrl = "https://mgw-backend.onrender.com/api"; // New base URL

  Future<void> fetchCourses() async { // Renamed from fetchSelectableCoursePackages for clarity
    if (_courses.isNotEmpty && !_isLoading) {
        return;
    }
    _isLoading = true;
    _error = null;
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/course'); // New endpoint
    print("Fetching course packages/semesters from: $url");

    try {
      final response = await http.get(url, headers: {
        "Accept": "application/json",
      });

      print("Course Packages/Semesters API Response Status: ${response.statusCode}");

      if (response.statusCode == 200) {
        final List<dynamic> extractedData = json.decode(response.body);
        if (extractedData is List) {
          _courses = extractedData
              .map((courseJson) => ApiCourse.fromJson(courseJson as Map<String, dynamic>))
              .toList();
          _error = null;
        } else {
          _error = 'Failed to load course packages: API response was not a list.';
          _courses = [];
        }
      } else {
        _error = 'Failed to load course packages. Status: ${response.statusCode}, Body: ${response.body}';
      }
    } catch (e) {
      _error = 'An unexpected error occurred: ${e.toString()}';
      print("Exception during fetchCourses: $_error");
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
   void clearError() {
    _error = null;
  }
}
// lib/provider/auth_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:image_picker/image_picker.dart'; // <<< ADD THIS IMPORT

import 'package:mgw_tutorial/models/user.dart';
import 'package:mgw_tutorial/models/auth_response.dart';
import 'package:mgw_tutorial/models/api_error.dart';

class AuthProvider with ChangeNotifier {
  User? _currentUser;
  String? _token;
  bool _isLoading = false;
  ApiError? _apiError;

  User? get currentUser => _currentUser;
  String? get token => _token;
  bool get isLoading => _isLoading;
  ApiError? get apiError => _apiError;

  static const String _apiBaseUrl = "https://usersservicefx.amtprinting19.com";

  void clearError() {
    _apiError = null;
  }

  void setErrorManually(String message) {
    _apiError = ApiError(message: message);
    notifyListeners();
  }

  String normalizePhoneNumberToE164(String rawPhoneNumber) {
    String cleanedNumber = rawPhoneNumber.replaceAll(RegExp(r'[^0-9]'), '');
    if (cleanedNumber.startsWith('251') && cleanedNumber.length == 12) return '+$cleanedNumber';
    if (cleanedNumber.startsWith('0') && cleanedNumber.length == 10) return '+251${cleanedNumber.substring(1)}';
    if (cleanedNumber.length == 9 && !cleanedNumber.startsWith('0')) return '+251$cleanedNumber';
    if (rawPhoneNumber.startsWith('+251') && rawPhoneNumber.length == 13) return rawPhoneNumber;
    
    if (cleanedNumber.length == 12 && cleanedNumber.startsWith('251')) return '+$cleanedNumber';
    if (cleanedNumber.length == 10 && cleanedNumber.startsWith('0')) return '+251${cleanedNumber.substring(1)}';
    if (cleanedNumber.length == 9) return '+251$cleanedNumber';
    
    print("Warning: Could not reliably normalize phone number '$rawPhoneNumber' to E.164 strictly. Returning best guess or original.");
    return rawPhoneNumber;
  }

  Future<bool> login({
    required String phoneNumber,
    required String password,
    required String deviceInfo,
  }) async {
    _isLoading = true;
    _apiError = null;
    notifyListeners();
    final String normalizedPhoneNumber = normalizePhoneNumberToE164(phoneNumber);
    final url = Uri.parse('$_apiBaseUrl/api/auth/login');
    final loginPayload = User(
      firstName: '', lastName: '', phone: normalizedPhoneNumber,
      password: password, device: deviceInfo,
    );
    try {
      final body = json.encode(loginPayload.toJsonForLogin());
      final response = await http.post(url, headers: {"Content-Type": "application/json", "Accept": "application/json"}, body: body);
      if (response.statusCode == 200) {
        final responseData = json.decode(response.body);
        final authResponse = AuthResponse.fromJson(responseData);
        _currentUser = authResponse.user;
        _token = authResponse.token;
        _isLoading = false;
        notifyListeners();
        return true;
      } else {
        _handleErrorResponse(response, 'Login failed.');
        return false;
      }
    } catch (error) {
      _handleCatchError(error, 'Exception during login');
      return false;
    }
  }
  
  Future<void> logout() async {
    _currentUser = null;
    _token = null;
    _apiError = null;
    notifyListeners();
  }
  
  Future<bool> signUpSimple({
    required String phoneNumber,
    required String password,
    String? firstName,
    String? lastName,
    String? languageCode,
    String? deviceInfo,
  }) async {
    _isLoading = true;
    _apiError = null;
    notifyListeners();

    final String normalizedPhone = normalizePhoneNumberToE164(phoneNumber); 

    final url = Uri.parse('$_apiBaseUrl/api/users');
    final userPayload = User(
      firstName: firstName ?? '',
      lastName: lastName ?? '',
      phone: normalizedPhone,
      password: password,
      device: deviceInfo,
    );
    try {
      final body = json.encode(userPayload.toJsonForSimpleSignUp());
      final response = await http.post(url, headers: {"Content-Type": "application/json", "Accept": "application/json"}, body: body);
      if (response.statusCode == 200 || response.statusCode == 201) {
        final responseData = json.decode(response.body);
        if (responseData.containsKey('user') && responseData.containsKey('token')) {
            final authResponse = AuthResponse.fromJson(responseData);
            _currentUser = authResponse.user;
            _token = authResponse.token;
        } else if (responseData.containsKey('id') && responseData.containsKey('phone')) {
            _currentUser = User.fromJson(responseData);
        }
        _isLoading = false;
        notifyListeners();
        return true;
      } else {
        _handleErrorResponse(response, 'Sign up failed.');
        return false;
      }
    } catch (error) {
      _handleCatchError(error, 'Exception during simple sign up');
      return false;
    }
  }

  Future<bool> registerUserFull({
    required User registrationData,
    XFile? screenshotFile, // XFile from image_picker
  }) async {
    _isLoading = true;
    _apiError = null;
    notifyListeners();

    final String normalizedPhoneForRegistration = normalizePhoneNumberToE164(registrationData.phone);
    final User updatedRegistrationData = User( 
      id: registrationData.id,
      firstName: registrationData.firstName,
      lastName: registrationData.lastName,
      phone: normalizedPhoneForRegistration,
      password: registrationData.password,
      allCourses: registrationData.allCourses,
      grade: registrationData.grade,
      category: registrationData.category,
      school: registrationData.school,
      gender: registrationData.gender,
      region: registrationData.region,
      status: registrationData.status,
      enrolledAll: registrationData.enrolledAll,
      device: registrationData.device,
      serviceType: registrationData.serviceType,
    );

    final url = Uri.parse('$_apiBaseUrl/api/users'); 
    try {
      final body = json.encode(updatedRegistrationData.toJsonForFullRegistration());
      final response = await http.post(url, headers: {"Content-Type": "application/json", "Accept": "application/json"}, body: body);
      if (response.statusCode == 200 || response.statusCode == 201) {
        _isLoading = false;
        notifyListeners();
        return true; 
      } else {
        _handleErrorResponse(response, 'Registration failed.');
        return false;
      }
    } catch (error) {
      _handleCatchError(error, 'Exception during full registration');
      return false;
    }
  }

  Future<Map<String, dynamic>> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    if (_token == null || _currentUser == null) {
      return {'success': false, 'message': 'User not authenticated. Please log in again.'};
    }
    _isLoading = true;
    _apiError = null;
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/api/auth/change-password'); 
    print("Changing password at: $url");

    try {
      final response = await http.put( 
        url,
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "Authorization": "Bearer $_token",
        },
        body: json.encode({
          'currentPassword': currentPassword, 
          'newPassword': newPassword,
        }),
      );
      print("Change password response: ${response.statusCode}, Body: ${response.body}");
      _isLoading = false;
      if (response.statusCode == 200 || response.statusCode == 204) {
        notifyListeners();
        return {'success': true, 'message': 'Password changed successfully.'};
      } else {
        _handleErrorResponse(response, 'Failed to change password.');
        return {'success': false, 'message': _apiError?.message ?? 'Failed to change password.'};
      }
    } catch (error) {
      _handleCatchError(error, 'Exception during password change');
      return {'success': false, 'message': _apiError?.message ?? 'An unexpected error occurred.'};
    }
  }

  Future<Map<String, dynamic>> requestPhoneChangeOTP({
    required String newRawPhoneNumber,
  }) async {
    if (_token == null || _currentUser == null) {
      return {'success': false, 'message': 'User not authenticated.'};
    }
    _isLoading = true;
    _apiError = null;
    notifyListeners();

    final normalizedNewPhone = normalizePhoneNumberToE164(newRawPhoneNumber);
    final url = Uri.parse('$_apiBaseUrl/api/auth/request-phone-change-otp'); 
    print("Requesting OTP for phone change to $normalizedNewPhone at: $url");

    try {
      final response = await http.post(
        url,
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "Authorization": "Bearer $_token",
        },
        body: json.encode({'newPhoneNumber': normalizedNewPhone}),
      );
      print("Request OTP response: ${response.statusCode}");
      _isLoading = false;
      if (response.statusCode == 200 || response.statusCode == 201) {
        notifyListeners();
        return {'success': true, 'message': 'OTP sent to $normalizedNewPhone (if endpoint is real).'};
      } else {
        _handleErrorResponse(response, 'Failed to request OTP for phone change.');
        return {'success': false, 'message': _apiError?.message ?? 'Failed to request OTP.'};
      }
    } catch (error) {
      _handleCatchError(error, 'Exception during OTP request for phone change');
      return {'success': false, 'message': _apiError?.message ?? 'An unexpected error occurred.'};
    }
  }

  Future<Map<String, dynamic>> verifyOtpAndChangePhone({
    required String newRawPhoneNumber,
    required String otp,
  }) async {
    if (_token == null || _currentUser == null) {
      return {'success': false, 'message': 'User not authenticated.'};
    }
    _isLoading = true;
    _apiError = null;
    notifyListeners();

    final normalizedNewPhone = normalizePhoneNumberToE164(newRawPhoneNumber);
    final userId = _currentUser!.id;
    if (userId == null) {
      _isLoading = false;
      notifyListeners();
      return {'success': false, 'message': 'User ID not found.'};
    }

    final url = Uri.parse('$_apiBaseUrl/api/users/update/$userId');
    print("Updating phone for user $userId to $normalizedNewPhone at: $url");

    Map<String, dynamic> updatePayload = {
      'phone': normalizedNewPhone,
      'first_name': _currentUser!.firstName,
      'last_name': _currentUser!.lastName,
      // Add other fields if your User model's toJsonForUpdate would include them
      // and if the API expects/allows them on this update.
      // For example:
      // if (_currentUser!.grade != null) 'grade': _currentUser!.grade,
      // if (_currentUser!.school != null) 'school': _currentUser!.school,
    };

    try {
      final response = await http.put(
        url,
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "Authorization": "Bearer $_token",
        },
        body: json.encode(updatePayload),
      );
      print("Update user (phone) response: ${response.statusCode}, Body: ${response.body}");
      _isLoading = false;
      if (response.statusCode == 200) {
        final responseData = json.decode(response.body);
        _currentUser = User.fromJson(responseData); 
        notifyListeners();
        return {'success': true, 'message': 'Phone number updated successfully.'};
      } else {
        _handleErrorResponse(response, 'Failed to update phone number.');
        return {'success': false, 'message': _apiError?.message ?? 'Failed to update phone number.'};
      }
    } catch (error) {
      _handleCatchError(error, 'Exception during phone number update');
      return {'success': false, 'message': _apiError?.message ?? 'An unexpected error occurred.'};
    }
  }

  void _handleErrorResponse(http.Response response, String defaultMessagePrefix) {
    String errorMessageToShow = '$defaultMessagePrefix. Status: ${response.statusCode}';
    try {
      final errorBody = json.decode(response.body);
      if (errorBody is Map) {
        if (errorBody.containsKey('message') && errorBody['message'] != null) {
           errorMessageToShow = errorBody['message'].toString();
           if (errorBody.containsKey('errors') && errorBody['errors'] is List && (errorBody['errors'] as List).isNotEmpty) {
             final fieldErrors = (errorBody['errors'] as List).map((e) {
               if (e is Map && e.containsKey('field') && e.containsKey('message')) {
                 return "${e['field']}: ${e['message']}";
               }
               return e.toString();
             }).join(', ');
             errorMessageToShow += " ($fieldErrors)";
           } else if (errorBody.containsKey('code') && errorBody['code'] != null) {
             errorMessageToShow += ' (Code: ${errorBody['code']})';
           }
        } else if (errorBody.containsKey('errorMessage') && errorBody['errorMessage'] != null) {
           errorMessageToShow = errorBody['errorMessage'].toString();
        } else if (response.body.isNotEmpty) {
            errorMessageToShow = '$defaultMessagePrefix: ${response.body}';
        }
      } else if (response.body.isNotEmpty) {
         errorMessageToShow = '$defaultMessagePrefix: ${response.body}';
      }
      _apiError = ApiError(message: errorMessageToShow);
    } catch (e) {
      _apiError = ApiError(message: '$defaultMessagePrefix. Status: ${response.statusCode}. Could not parse error: ${response.body}');
    }
    _isLoading = false;
    notifyListeners();
  }

  void _handleCatchError(dynamic error, String messagePrefix) {
    print('$messagePrefix: ${error.toString()}');
    _apiError = ApiError(message: '$messagePrefix: An unexpected error occurred. Please try again.');
    _isLoading = false;
    notifyListeners();
  }
}
// lib/provider/comment_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/comment.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';

class CommentProvider with ChangeNotifier {
  Map<int, List<Comment>> _commentsByPostId = {};
  Map<int, bool> _isLoadingForPostId = {};
  Map<int, String?> _errorForPostId = {};

  List<Comment> commentsForPost(int postId) => _commentsByPostId[postId] ?? [];
  bool isLoadingForPost(int postId) => _isLoadingForPostId[postId] ?? false;
  String? errorForPost(int postId) => _errorForPostId[postId];

  final String _apiBaseUrl; // This will be "https://mgw-backend.onrender.com/api"
  final AuthProvider _authProvider;

  CommentProvider(this._apiBaseUrl, this._authProvider);

  Future<void> fetchCommentsForPost(int postId, {bool forceRefresh = false}) async {
    if (!forceRefresh && _commentsByPostId.containsKey(postId) && !(_isLoadingForPostId[postId] ?? false)) {
      return;
    }
    _isLoadingForPostId[postId] = true;
    _errorForPostId[postId] = null;
    notifyListeners();

    // UPDATED URL
    final url = Uri.parse('$_apiBaseUrl/post-comments?postId=$postId');
    try {
      final response = await http.get(url, headers: {"Accept": "application/json"});
      if (response.statusCode == 200) {
        final List<dynamic> data = json.decode(response.body);
        _commentsByPostId[postId] = data.map((cJson) => Comment.fromJson(cJson as Map<String, dynamic>)).toList();
        _commentsByPostId[postId]?.sort((a, b) => a.createdAt.compareTo(b.createdAt));
        _errorForPostId[postId] = null;
      } else {
        _errorForPostId[postId] = "Failed to load comments for post $postId: ${response.body}";
      }
    } catch (e) {
      _errorForPostId[postId] = "Error fetching comments for post $postId: ${e.toString()}";
    } finally {
      _isLoadingForPostId[postId] = false;
      notifyListeners();
    }
  }

  Future<Map<String, dynamic>> createComment({required int postId, required String commentText}) async {
     if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;
    // UPDATED URL
    final url = Uri.parse('$_apiBaseUrl/post-comments');
    try {
      final response = await http.post(
        url,
        headers: {"Content-Type": "application/json", "Accept": "application/json", "X-User-ID": userId.toString()},
        body: json.encode({'comment': commentText, 'userId': userId, 'postId': postId}),
      );
      if (response.statusCode == 201) {
        final newComment = Comment.fromJson(json.decode(response.body) as Map<String, dynamic>);
        _commentsByPostId[postId] = [...(_commentsByPostId[postId] ?? []), newComment];
        _commentsByPostId[postId]?.sort((a, b) => a.createdAt.compareTo(b.createdAt));
        notifyListeners();
        return {'success': true, 'message': "Comment created.", 'comment': newComment};
      } else {
        return {'success': false, 'message': "Failed to create comment: ${response.body}"};
      }
    } catch (e) {
      return {'success': false, 'message': "Error creating comment: ${e.toString()}"};
    }
  }

  Future<Map<String, dynamic>> updateComment({required int commentId, required int postId, required String newCommentText}) async {
     if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;
    // UPDATED URL
    final url = Uri.parse('$_apiBaseUrl/post-comments/$commentId');
    try {
      final response = await http.put(
        url,
        headers: {"Content-Type": "application/json", "Accept": "application/json", "X-User-ID": userId.toString()},
        body: json.encode({'comment': newCommentText, 'userId': userId}), // Assuming API still takes userId for update validation
      );
      if (response.statusCode == 200 || response.statusCode == 204) {
        if (_commentsByPostId.containsKey(postId)) {
          final index = _commentsByPostId[postId]!.indexWhere((c) => c.id == commentId);
          if (index != -1) {
            _commentsByPostId[postId]![index] = _commentsByPostId[postId]![index].copyWith(comment: newCommentText, updatedAt: DateTime.now());
            notifyListeners();
          }
        }
        return {'success': true, 'message': "Comment updated."};
      } else {
        return {'success': false, 'message': "Failed to update comment: ${response.body}"};
      }
    } catch (e) {
      return {'success': false, 'message': "Error updating comment: ${e.toString()}"};
    }
  }
  Future<Map<String, dynamic>> deleteComment({required int commentId, required int postId}) async {
    if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;
    // UPDATED URL
    final url = Uri.parse('$_apiBaseUrl/post-comments/$commentId');
    try {
      final response = await http.delete(url, headers: {"Accept": "application/json", "X-User-ID": userId.toString()});
      if (response.statusCode == 200 || response.statusCode == 204) {
        _commentsByPostId[postId]?.removeWhere((c) => c.id == commentId);
        notifyListeners();
        return {'success': true, 'message': "Comment deleted."};
      } else {
        return {'success': false, 'message': "Failed to delete comment: ${response.body}"};
      }
    } catch (e) {
      return {'success': false, 'message': "Error deleting comment: ${e.toString()}"};
    }
  }
}
// lib/provider/department_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/department.dart'; // Adjust path if needed

class DepartmentProvider with ChangeNotifier {
  List<Department> _departments = [];
  bool _isLoading = false;
  String? _error;

  List<Department> get departments => [..._departments];
  bool get isLoading => _isLoading;
  String? get error => _error;

  // API Base URL - ensure this is consistent with your other providers
  static const String _apiBaseUrl = "https://mgw-backend.onrender.com/api";

  Future<void> fetchDepartments() async {
    if (_departments.isNotEmpty) return; // Avoid refetching if already loaded

    _isLoading = true;
    _error = null;
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/departments');

    try {
      print("Fetching departments from: $url");
      final response = await http.get(url, headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
      });
      print("Departments Response status: ${response.statusCode}");

      if (response.statusCode == 200) {
        final List<dynamic> extractedData = json.decode(response.body);
        if (extractedData is List) {
          _departments = extractedData
              .map((deptData) => Department.fromJson(deptData as Map<String, dynamic>))
              .toList();
        } else {
          _error = 'Failed to load departments: Response format is not a list.';
          print(_error);
        }
      } else {
        String errorMessage = 'Failed to load departments. Status: ${response.statusCode}';
        try {
          final errorData = json.decode(response.body);
          if (errorData != null && errorData['message'] != null) {
            errorMessage = errorData['message'];
          } else if (response.body.isNotEmpty) {
            errorMessage += "\nResponse: ${response.body}";
          }
        } catch (e) {
          errorMessage += "\nRaw response: ${response.body}";
        }
        _error = errorMessage;
        print("Error fetching departments: $_error");
      }
    } catch (e) {
      _error = 'An unexpected error occurred: ${e.toString()}';
      print("Exception fetching departments: $_error");
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}
// lib/provider/discussion_provider.dart
import 'package:flutter/foundation.dart';
import 'package:mgw_tutorial/models/post.dart';
import 'package:mgw_tutorial/models/comment.dart';
import 'package:mgw_tutorial/models/reply.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/provider/post_provider.dart';
import 'package:mgw_tutorial/provider/comment_provider.dart';
import 'package:mgw_tutorial/provider/reply_provider.dart';

class DiscussionProvider with ChangeNotifier {
  final AuthProvider _authProvider;
  late final PostProvider _postProvider;
  late final CommentProvider _commentProvider;
  late final ReplyProvider _replyProvider;

  static const String _apiBaseUrl = "https://mgw-backend.onrender.com/api";

  // UI specific error states for submission forms
  String? _submitPostError;
  String? _submitCommentError;
  String? _submitReplyError;
  String? _updateItemError; // Generic for updates
  String? _deleteItemError; // Generic for deletes

  // UI specific loading states for submission/action
  bool _isSubmittingPost = false;
  bool _isSubmittingComment = false;
  bool _isSubmittingReply = false;
  bool _isUpdatingItem = false;
  bool _isDeletingItem = false;


  DiscussionProvider(this._authProvider) {
    _postProvider = PostProvider(_apiBaseUrl, _authProvider);
    _commentProvider = CommentProvider(_apiBaseUrl, _authProvider);
    _replyProvider = ReplyProvider(_apiBaseUrl, _authProvider);

    // Listen to changes in sub-providers to trigger notifyListeners in DiscussionProvider
    // This ensures that consumers of DiscussionProvider update when sub-provider data changes.
    _postProvider.addListener(_notifyDiscussionListeners);
    _commentProvider.addListener(_notifyDiscussionListeners);
    _replyProvider.addListener(_notifyDiscussionListeners);
  }

  void _notifyDiscussionListeners() {
    notifyListeners();
  }

  @override
  void dispose() {
    _postProvider.removeListener(_notifyDiscussionListeners);
    _commentProvider.removeListener(_notifyDiscussionListeners);
    _replyProvider.removeListener(_notifyDiscussionListeners);
    _postProvider.dispose();
    _commentProvider.dispose();
    _replyProvider.dispose();
    super.dispose();
  }

  // --- Getters for Data (delegating to sub-providers) ---
  List<Post> get posts => _postProvider.posts;
  bool get isLoadingPosts => _postProvider.isLoading;
  String? get postsError => _postProvider.error;

  List<Comment> commentsForPost(int postId) => _commentProvider.commentsForPost(postId);
  bool isLoadingCommentsForPost(int postId) => _commentProvider.isLoadingForPost(postId);
  String? commentErrorForPost(int postId) => _commentProvider.errorForPost(postId);
  
  List<Reply> repliesForComment(int commentId) => _replyProvider.repliesForComment(commentId);
  bool isLoadingRepliesForComment(int commentId) => _replyProvider.isLoadingForComment(commentId);
  String? replyErrorForComment(int commentId) => _replyProvider.errorForComment(commentId);
  bool allRepliesLoadedForComment(int commentId) => _replyProvider.allRepliesLoadedForComment(commentId);


  // --- Getters for UI-specific states ---
  String? get submitPostError => _submitPostError;
  String? get submitCommentError => _submitCommentError;
  String? get submitReplyError => _submitReplyError;
  String? get updateItemError => _updateItemError;
  String? get deleteItemError => _deleteItemError;

  bool get isSubmittingPost => _isSubmittingPost;
  bool get isSubmittingComment => _isSubmittingComment;
  bool get isSubmittingReply => _isSubmittingReply;
  bool get isUpdatingItem => _isUpdatingItem;
  bool get isDeletingItem => _isDeletingItem;

  // --- Post Methods ---
  Future<void> fetchPosts() async => await _postProvider.fetchPosts();

  Future<bool> createPost({required String title, required String description}) async {
    _isSubmittingPost = true;
    _submitPostError = null;
    notifyListeners();
    final result = await _postProvider.createPost(title: title, description: description);
    _isSubmittingPost = false;
    if (!result['success']) _submitPostError = result['message'];
    notifyListeners();
    return result['success'];
  }
  // ... (Update/Delete Post methods delegating and managing UI state)
  Future<bool> updatePost({required int postId, required String title, required String description}) async {
    _isUpdatingItem = true; _updateItemError = null; notifyListeners();
    final result = await _postProvider.updatePost(postId: postId, title: title, description: description);
    _isUpdatingItem = false;
    if (!result['success']) _updateItemError = result['message'];
    notifyListeners();
    return result['success'];
  }

  Future<bool> deletePost(int postId) async {
    _isDeletingItem = true; _deleteItemError = null; notifyListeners();
    final result = await _postProvider.deletePost(postId);
    _isDeletingItem = false;
    if (!result['success']) _deleteItemError = result['message'];
    notifyListeners();
    return result['success'];
  }


  // --- Comment Methods ---
  Future<void> fetchCommentsForPost(int postId, {bool forceRefresh = false}) async => await _commentProvider.fetchCommentsForPost(postId, forceRefresh: forceRefresh);

  Future<bool> createTopLevelComment({required int postId, required String commentText}) async {
    _isSubmittingComment = true;
    _submitCommentError = null;
    notifyListeners();
    final result = await _commentProvider.createComment(postId: postId, commentText: commentText);
    _isSubmittingComment = false;
    if (!result['success']) _submitCommentError = result['message'];
    notifyListeners();
    return result['success'];
  }
   Future<bool> updateComment({required int commentId, required int postId, required String newCommentText}) async {
    _isUpdatingItem = true; _updateItemError = null; notifyListeners();
    final result = await _commentProvider.updateComment(commentId: commentId, postId: postId, newCommentText: newCommentText);
    _isUpdatingItem = false;
    if (!result['success']) _updateItemError = result['message'];
    notifyListeners();
    return result['success'];
  }

  Future<bool> deleteComment({required int commentId, required int postId}) async {
    _isDeletingItem = true; _deleteItemError = null; notifyListeners();
    final result = await _commentProvider.deleteComment(commentId: commentId, postId: postId);
    _isDeletingItem = false;
    if (!result['success']) _deleteItemError = result['message'];
    notifyListeners();
    return result['success'];
  }


  // --- Reply Methods ---
  Future<void> fetchRepliesForComment(int commentId, {bool forceRefresh = false}) async => await _replyProvider.fetchRepliesForComment(commentId, forceRefresh: forceRefresh);
  
  Future<bool> createReply({required int parentCommentId, required String content}) async {
    _isSubmittingReply = true;
    _submitReplyError = null;
    notifyListeners();
    final result = await _replyProvider.createReply(parentCommentId: parentCommentId, content: content);
    _isSubmittingReply = false;
    if (!result['success']) _submitReplyError = result['message'];
    notifyListeners();
    return result['success'];
  }
  Future<bool> updateReply({required int parentCommentId, required int replyId, required String newContent}) async {
    _isUpdatingItem = true; _updateItemError = null; notifyListeners();
    final result = await _replyProvider.updateReply(parentCommentId: parentCommentId, replyId: replyId, newContent: newContent);
    _isUpdatingItem = false;
    if (!result['success']) _updateItemError = result['message'];
    notifyListeners();
    return result['success'];
  }

  Future<bool> deleteReply({required int parentCommentId, required int replyId}) async {
    _isDeletingItem = true; _deleteItemError = null; notifyListeners();
    final result = await _replyProvider.deleteReply(parentCommentId: parentCommentId, replyId: replyId);
    _isDeletingItem = false;
    if (!result['success']) _deleteItemError = result['message'];
    notifyListeners();
    return result['success'];
  }
}
// lib/provider/lesson_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/lesson.dart';

class LessonProvider with ChangeNotifier {
  Map<int, List<Lesson>> _lessonsBySectionId = {};
  Map<int, bool> _isLoadingForSectionId = {};
  Map<int, String?> _errorForSectionId = {};

  List<Lesson> lessonsForSection(int sectionId) => _lessonsBySectionId[sectionId] ?? [];
  bool isLoadingForSection(int sectionId) => _isLoadingForSectionId[sectionId] ?? false;
  String? errorForSection(int sectionId) => _errorForSectionId[sectionId];

  // <<< UPDATED BASE URL >>>
  static const String _apiBaseUrl = "https://lessonservice.amtprinting19.com/api";

  Future<void> fetchLessonsForSection(int sectionId, {bool forceRefresh = false}) async {
    if (!forceRefresh && _lessonsBySectionId.containsKey(sectionId) && !(_isLoadingForSectionId[sectionId] ?? false)) {
      return;
    }

    _isLoadingForSectionId[sectionId] = true;
    _errorForSectionId[sectionId] = null;
    if (forceRefresh) { // Clear existing if forcing
      _lessonsBySectionId.remove(sectionId);
    }
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/lessons/section/$sectionId');
    print("Fetching lessons for section $sectionId from: $url");

    try {
      final response = await http.get(url, headers: {"Accept": "application/json"});
      print("Lessons API Response for section $sectionId Status: ${response.statusCode}");

      if (response.statusCode == 200) {
        final List<dynamic> extractedData = json.decode(response.body);
        if (extractedData is List) {
          _lessonsBySectionId[sectionId] = extractedData
              .map((lessonJson) => Lesson.fromJson(lessonJson as Map<String, dynamic>))
              .toList();
          _lessonsBySectionId[sectionId]?.sort((a, b) => (a.order ?? 0).compareTo(b.order ?? 0));
          _errorForSectionId[sectionId] = null;
        } else {
          _errorForSectionId[sectionId] = 'Failed to load lessons for section $sectionId: API response was not a list.';
          _lessonsBySectionId[sectionId] = [];
        }
      } else {
        _errorForSectionId[sectionId] = 'Failed to load lessons for section $sectionId. Status: ${response.statusCode}, Body: ${response.body}';
      }
    } catch (e) {
      _errorForSectionId[sectionId] = 'An error occurred fetching lessons for section $sectionId: ${e.toString()}';
    } finally {
      _isLoadingForSectionId[sectionId] = false;
      notifyListeners();
    }
  }
  
  void clearErrorForSection(int sectionId) {
    _errorForSectionId[sectionId] = null;
  }
}
//lib/provider/locale_provider.dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class LocaleProvider with ChangeNotifier {
  Locale? _locale;
  static const String _selectedLocaleKey = 'selected_locale';

  Locale? get locale => _locale;

  LocaleProvider() {
    _loadLocale(); // Load saved locale on initialization
  }

  Future<void> _loadLocale() async {
    final prefs = await SharedPreferences.getInstance();
    final String? languageCode = prefs.getString(_selectedLocaleKey);
    if (languageCode != null && languageCode.isNotEmpty) {
      _locale = Locale(languageCode);
    }
    notifyListeners(); // Notify listeners even if no locale was loaded, to trigger initial build
  }

  // Method to set the locale and save it
  Future<void> setLocale(Locale locale) async {
    _locale = locale;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_selectedLocaleKey, locale.languageCode);
    notifyListeners();
  }

  // Method to clear the saved locale (revert to system default)
  Future<void> clearLocale() async {
    _locale = null; // Setting to null will make MaterialApp use system/default
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_selectedLocaleKey);
    notifyListeners();
  }
}
// lib/provider/order_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:image_picker/image_picker.dart'; // Import XFile
import 'package:mgw_tutorial/models/order.dart';
import 'package:http_parser/http_parser.dart'; // For MediaType

class OrderProvider with ChangeNotifier {
  bool _isLoading = false;
  String? _error;
  Order? _lastCreatedOrder;

  bool get isLoading => _isLoading;
  String? get error => _error;
  Order? get lastCreatedOrder => _lastCreatedOrder;

  static const String _apiBaseUrl = "https://adminservicefx.amtprinting19.com/api";

  // Modify createOrder to accept XFile
  Future<bool> createOrder({
    required Order orderData, // Contains all non-file data
    XFile? screenshotFile,   // The image file
  }) async {
    _isLoading = true;
    _error = null;
    _lastCreatedOrder = null;
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/orders');
    
    try {
      var request = http.MultipartRequest('POST', url);

      // Add text fields from orderData.toJsonForApi()
      // Note: The API might expect all fields as strings in multipart.
      // If so, you might need to convert numbers/booleans to strings here.
      Map<String, dynamic> orderFields = orderData.toJsonForApi();
      orderFields.forEach((key, value) {
        // The 'screenshot' field from toJsonForApi might be a path or null,
        // we are sending the actual file below, so we can choose to exclude it here
        // or ensure the backend can handle both a 'screenshot' text field and a file.
        // For now, let's assume the backend primarily looks for the file part.
        if (key != 'screenshot' && value != null) { // Exclude null values and the text 'screenshot' field
             request.fields[key] = value.toString(); // Ensure value is a string
        }
      });
      
      print('Order Multipart Request Fields: ${request.fields}');


      // Add the screenshot file if it exists
     /*  if (screenshotFile != null) {
        request.files.add(
          await http.MultipartFile.fromPath(
            'screenshot', // This is the field name the backend expects for the file
            screenshotFile.path,
            contentType: MediaType('image', screenshotFile.path.split('.').last), // e.g., image/jpeg, image/png
          ),
        );
        print('Order Multipart Request File: ${screenshotFile.name}');
      } else {
        print('Order Multipart Request: No screenshot file provided.');
        // If screenshot is mandatory, you might want to return false here or handle it.
        // Or, if the API allows orders without screenshots, this is fine.
        // The 'screenshot' field in request.fields will be null or absent if not in toJsonForApi
      } */
      
      // Add headers if needed
      // request.headers.addAll({
      //   "Accept": "application/json",
      //   // "Authorization": "Bearer YOUR_ADMIN_TOKEN_IF_NEEDED",
      // });

      var streamedResponse = await request.send();
      var response = await http.Response.fromStream(streamedResponse);

      print('Order Creation Response (Multipart): ${response.statusCode} ${response.body}');

      if (response.statusCode == 201 || response.statusCode == 200) {
        final responseData = json.decode(response.body);
        _lastCreatedOrder = Order.fromJson(responseData);
        _isLoading = false;
        notifyListeners();
        return true;
      } else {
        _error = "Failed to create order. Status: ${response.statusCode}. Body: ${response.body}";
        _isLoading = false;
        notifyListeners();
        return false;
      }
    } catch (e) {
      _error = "An exception occurred while creating order: ${e.toString()}";
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  void clearError() {
    _error = null;
    // notifyListeners();
  }
}
// lib/provider/post_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/post.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart'; // For user ID

class PostProvider with ChangeNotifier {
  List<Post> _posts = [];
  bool _isLoading = false;
  String? _error;

  List<Post> get posts => [..._posts];
  bool get isLoading => _isLoading;
  String? get error => _error;

  final String _apiBaseUrl;
  final AuthProvider _authProvider;

  PostProvider(this._apiBaseUrl, this._authProvider) {
    // Optionally fetch posts on initialization if needed by DiscussionProvider
    // fetchPosts();
  }

  Future<void> fetchPosts() async {
    _isLoading = true;
    _error = null;
    notifyListeners();
    final url = Uri.parse('$_apiBaseUrl/posts');
    try {
      final response = await http.get(url, headers: {"Accept": "application/json"});
      if (response.statusCode == 200) {
        final List<dynamic> extractedData = json.decode(response.body);
        _posts = extractedData.map((postData) => Post.fromJson(postData as Map<String, dynamic>)).toList();
        _posts.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        _error = null;
      } else {
        _error = "Failed to load posts. Status: ${response.statusCode}";
      }
    } catch (e) {
      _error = "Error fetching posts: ${e.toString()}";
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<Map<String, dynamic>> createPost({required String title, required String description}) async {
    if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;
    final url = Uri.parse('$_apiBaseUrl/posts');
    try {
      final response = await http.post(
        url,
        headers: {"Content-Type": "application/json", "Accept": "application/json", "X-User-ID": userId.toString()},
        body: json.encode({'title': title, 'description': description, 'userId': userId}),
      );
      if (response.statusCode == 201) {
        final newPost = Post.fromJson(json.decode(response.body));
        _posts.insert(0, newPost); // Add to start for newest first
        notifyListeners();
        return {'success': true, 'message': "Post created."};
      } else {
        return {'success': false, 'message': "Failed to create post: ${response.body}"};
      }
    } catch (e) {
      return {'success': false, 'message': "Error creating post: ${e.toString()}"};
    }
  }

  Future<Map<String, dynamic>> updatePost({required int postId, required String title, required String description}) async {
    if (_authProvider.currentUser?.id == null) {
       return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!; // For validation or if API needs it
    final url = Uri.parse('$_apiBaseUrl/posts/$postId');
    try {
      final response = await http.put(
        url,
        headers: {"Content-Type": "application/json", "Accept": "application/json", "X-User-ID": userId.toString()},
        body: json.encode({'title': title, 'description': description, 'userId': userId}),
      );
      if (response.statusCode == 200 || response.statusCode == 204) {
        final index = _posts.indexWhere((p) => p.id == postId);
        if (index != -1) {
            // Assuming API doesn't return the full updated post, or we don't parse it here
             _posts[index] = _posts[index].copyWith(title: title, description: description, updatedAt: DateTime.now());
             notifyListeners();
        }
        return {'success': true, 'message': "Post updated."};
      } else {
        return {'success': false, 'message': "Failed to update post: ${response.body}"};
      }
    } catch (e) {
      return {'success': false, 'message': "Error updating post: ${e.toString()}"};
    }
  }

  Future<Map<String, dynamic>> deletePost(int postId) async {
    if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;
    final url = Uri.parse('$_apiBaseUrl/posts/$postId');
    try {
      final response = await http.delete(url, headers: {"Accept": "application/json", "X-User-ID": userId.toString()});
      if (response.statusCode == 200 || response.statusCode == 204) {
        _posts.removeWhere((post) => post.id == postId);
        notifyListeners();
        return {'success': true, 'message': "Post deleted."};
      } else {
        return {'success': false, 'message': "Failed to delete post: ${response.body}"};
      }
    } catch (e) {
      return {'success': false, 'message': "Error deleting post: ${e.toString()}"};
    }
  }
}
// lib/provider/reply_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/reply.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';

class ReplyProvider with ChangeNotifier {
  Map<int, List<Reply>> _repliesByCommentId = {};
  Map<int, bool> _isLoadingForCommentId = {};
  Map<int, String?> _errorForCommentId = {};
  Map<int, bool> _allRepliesLoadedForCommentId = {}; // To track if all replies have been fetched

  List<Reply> repliesForComment(int commentId) => _repliesByCommentId[commentId] ?? [];
  bool isLoadingForComment(int commentId) => _isLoadingForCommentId[commentId] ?? false;
  String? errorForComment(int commentId) => _errorForCommentId[commentId];
  bool allRepliesLoadedForComment(int commentId) => _allRepliesLoadedForCommentId[commentId] ?? false;

  final String _apiBaseUrl; // This will be "https://mgw-backend.onrender.com/api"
  final AuthProvider _authProvider;

  ReplyProvider(this._apiBaseUrl, this._authProvider);

  // Fetches replies for a specific comment.
  // The API endpoint /post-comments/{commentId}/replies likely gets ALL replies for that comment.
  Future<void> fetchRepliesForComment(int commentId, {bool forceRefresh = false}) async {
    // If already loaded and not forcing refresh, and all replies are marked as loaded, return.
    if (!forceRefresh &&
        _repliesByCommentId.containsKey(commentId) &&
        !(_isLoadingForCommentId[commentId] ?? false) &&
        (_allRepliesLoadedForCommentId[commentId] ?? false) ) {
      return;
    }

    _isLoadingForCommentId[commentId] = true;
    _errorForCommentId[commentId] = null;
    if (forceRefresh) { // If forcing refresh, reset loaded status
      _allRepliesLoadedForCommentId[commentId] = false;
    }
    notifyListeners();

    // UPDATED URL for fetching replies for a comment
    final url = Uri.parse('$_apiBaseUrl/post-comments/$commentId/replies');
    print("Fetching replies for comment $commentId from: $url");

    try {
      final response = await http.get(url, headers: {"Accept": "application/json"});
      print("Fetch replies response for comment $commentId: ${response.statusCode}, Body: ${response.body.substring(0, (response.body.length > 200 ? 200 : response.body.length))}");


      if (response.statusCode == 200) {
        final List<dynamic> data = json.decode(response.body);
        _repliesByCommentId[commentId] = data.map((rJson) {
          try {
            return Reply.fromJson(rJson as Map<String, dynamic>);
          } catch (e) {
            print("Error parsing reply JSON for comment $commentId: $e, JSON: $rJson");
            // Return a dummy/error reply or rethrow, depending on desired behavior
            // For now, let's skip problematic replies
            return null;
          }
        }).whereType<Reply>().toList(); // Filter out nulls if any parsing failed

        _repliesByCommentId[commentId]?.sort((a, b) => a.createdAt.compareTo(b.createdAt));
        _errorForCommentId[commentId] = null;
        _allRepliesLoadedForCommentId[commentId] = true; // Mark all replies as loaded for this comment
      } else {
        _errorForCommentId[commentId] = "Failed to load replies for comment $commentId. Status: ${response.statusCode}, Body: ${response.body}";
      }
    } catch (e) {
      _errorForCommentId[commentId] = "Error fetching replies for comment $commentId: ${e.toString()}";
      print("Exception fetching replies for comment $commentId: $e");
    } finally {
      _isLoadingForCommentId[commentId] = false;
      notifyListeners();
    }
  }

  Future<Map<String, dynamic>> createReply({required int parentCommentId, required String content}) async {
    if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;

    // UPDATED URL for creating a reply to a specific comment
    final url = Uri.parse('$_apiBaseUrl/post-comments/$parentCommentId/replies');
    print("Creating reply to comment $parentCommentId at: $url with content: $content by user: $userId");

    try {
      final response = await http.post(
        url,
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-User-ID": userId.toString() // Assuming your backend uses this header for user identification
        },
        body: json.encode({
          'content': content,
          'userId': userId,
          // 'postCommentId': parentCommentId, // The backend might infer parentCommentId from the URL
        }),
      );

      print("Create reply response: ${response.statusCode}, Body: ${response.body}");

      if (response.statusCode == 201) {
        final newReplyJson = json.decode(response.body) as Map<String, dynamic>;
        final newReply = Reply.fromJson(newReplyJson);

        // Add to the local list
        _repliesByCommentId.putIfAbsent(parentCommentId, () => []);
        _repliesByCommentId[parentCommentId]!.add(newReply);
        _repliesByCommentId[parentCommentId]?.sort((a, b) => a.createdAt.compareTo(b.createdAt));

        notifyListeners();
        return {'success': true, 'message': "Reply created.", 'reply': newReply};
      } else {
        return {'success': false, 'message': "Failed to create reply. Status: ${response.statusCode}, Body: ${response.body}"};
      }
    } catch (e) {
      print("Exception creating reply: $e");
      return {'success': false, 'message': "Error creating reply: ${e.toString()}"};
    }
  }

  Future<Map<String, dynamic>> updateReply({required int parentCommentId, required int replyId, required String newContent}) async {
    if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;

    // UPDATED URL for updating a specific reply
    // The API path implies the parentCommentId is part of the route to identify the reply.
    final url = Uri.parse('$_apiBaseUrl/post-comments/$parentCommentId/replies/$replyId');
    print("Updating reply $replyId (parent $parentCommentId) at: $url with new content: $newContent");

    try {
      final response = await http.put(
        url,
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-User-ID": userId.toString()
        },
        body: json.encode({
          'content': newContent,
          // 'userId': userId, // Backend might only need content and validate user via X-User-ID
        }),
      );
      print("Update reply response: ${response.statusCode}, Body: ${response.body}");

      if (response.statusCode == 200 || response.statusCode == 204) {
        if (_repliesByCommentId.containsKey(parentCommentId)) {
          final index = _repliesByCommentId[parentCommentId]!.indexWhere((r) => r.id == replyId);
          if (index != -1) {
            // If the backend returns the updated reply, parse it. Otherwise, update locally.
            try {
              if (response.body.isNotEmpty) { // Check if response body is not empty before decoding
                  final updatedReplyData = json.decode(response.body);
                  _repliesByCommentId[parentCommentId]![index] = Reply.fromJson(updatedReplyData as Map<String, dynamic>);
              } else { // If 204 No Content or empty body
                   _repliesByCommentId[parentCommentId]![index] = _repliesByCommentId[parentCommentId]![index].copyWith(content: newContent, updatedAt: DateTime.now());
              }
            } catch (e) {
                 print("Error parsing updated reply or body was empty: $e. Updating locally.");
                 _repliesByCommentId[parentCommentId]![index] = _repliesByCommentId[parentCommentId]![index].copyWith(content: newContent, updatedAt: DateTime.now());
            }
            notifyListeners();
          }
        }
        return {'success': true, 'message': "Reply updated."};
      } else {
        return {'success': false, 'message': "Failed to update reply. Status: ${response.statusCode}, Body: ${response.body}"};
      }
    } catch (e) {
      print("Exception updating reply: $e");
      return {'success': false, 'message': "Error updating reply: ${e.toString()}"};
    }
  }

  Future<Map<String, dynamic>> deleteReply({required int parentCommentId, required int replyId}) async {
    if (_authProvider.currentUser?.id == null) {
      return {'success': false, 'message': "User not authenticated."};
    }
    final int userId = _authProvider.currentUser!.id!;

    // UPDATED URL for deleting a specific reply
    final url = Uri.parse('$_apiBaseUrl/post-comments/$parentCommentId/replies/$replyId');
    print("Deleting reply $replyId (parent $parentCommentId) at: $url");

    try {
      final response = await http.delete(
        url,
        headers: {
          "Accept": "application/json",
          "X-User-ID": userId.toString()
        },
      );
      print("Delete reply response: ${response.statusCode}, Body: ${response.body}");

      if (response.statusCode == 200 || response.statusCode == 204) {
        _repliesByCommentId[parentCommentId]?.removeWhere((r) => r.id == replyId);
        notifyListeners();
        return {'success': true, 'message': "Reply deleted."};
      } else {
        return {'success': false, 'message': "Failed to delete reply. Status: ${response.statusCode}, Body: ${response.body}"};
      }
    } catch (e) {
      print("Exception deleting reply: $e");
      return {'success': false, 'message': "Error deleting reply: ${e.toString()}"};
    }
  }
}
// lib/provider/section_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/section.dart';

class SectionProvider with ChangeNotifier {
  Map<int, List<Section>> _sectionsByCourseId = {};
  Map<int, bool> _isLoadingForCourseId = {};
  Map<int, String?> _errorForCourseId = {};

  List<Section> sectionsForCourse(int courseId) => _sectionsByCourseId[courseId] ?? [];
  bool isLoadingForCourse(int courseId) => _isLoadingForCourseId[courseId] ?? false;
  String? errorForCourse(int courseId) => _errorForCourseId[courseId];

  // <<< UPDATED BASE URL >>>
  static const String _apiBaseUrl = "https://sectionservicefx.amtprinting19.com/api";

  Future<void> fetchSectionsForCourse(int courseId, {bool forceRefresh = false}) async {
    if (!forceRefresh && _sectionsByCourseId.containsKey(courseId) && !(_isLoadingForCourseId[courseId] ?? false)) {
      return;
    }

    _isLoadingForCourseId[courseId] = true;
    _errorForCourseId[courseId] = null;
     if (forceRefresh) { // Clear existing if forcing
      _sectionsByCourseId.remove(courseId);
    }
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/sections/course/$courseId');
    print("Fetching sections for course $courseId from: $url");

    try {
      final response = await http.get(url, headers: {"Accept": "application/json"});
      print("Sections API Response for course $courseId Status: ${response.statusCode}");

      if (response.statusCode == 200) {
        final List<dynamic> extractedData = json.decode(response.body);
        if (extractedData is List) {
          _sectionsByCourseId[courseId] = extractedData
              .map((sectionJson) => Section.fromJson(sectionJson as Map<String, dynamic>))
              .toList();
          _sectionsByCourseId[courseId]?.sort((a, b) => (a.order ?? 0).compareTo(b.order ?? 0));
          _errorForCourseId[courseId] = null;
        } else {
          _errorForCourseId[courseId] = 'Failed to load sections for course $courseId: API response was not a list.';
          _sectionsByCourseId[courseId] = [];
        }
      } else {
        _errorForCourseId[courseId] = 'Failed to load sections for course $courseId. Status: ${response.statusCode}, Body: ${response.body}';
      }
    } catch (e) {
      _errorForCourseId[courseId] = 'An error occurred fetching sections for course $courseId: ${e.toString()}';
    } finally {
      _isLoadingForCourseId[courseId] = false;
      notifyListeners();
    }
  }

  void clearErrorForCourse(int courseId) {
    _errorForCourseId[courseId] = null;
  }
}
// lib/provider/semester_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/semester.dart';

class SemesterProvider with ChangeNotifier {
  List<Semester> _semesters = [];
  bool _isLoading = false;
  String? _error;

  List<Semester> get semesters => [..._semesters];
  bool get isLoading => _isLoading;
  String? get error => _error;

  static const String _apiBaseUrl = "https://mgw-backend.onrender.com/api";

  // MODIFIED to accept forceRefresh
  Future<void> fetchSemesters({bool forceRefresh = false}) async {
    // If not forcing refresh, and data exists and not currently loading, return.
    if (!forceRefresh && _semesters.isNotEmpty && !_isLoading) {
      // print("Semesters already loaded. Skipping fetch.");
      // notifyListeners(); // Optionally notify if UI needs to react to "using cached" state
      return;
    }

    _isLoading = true;
    // If forcing refresh, clear existing data and error to ensure a clean fetch
    if (forceRefresh) {
      _semesters = [];
      _error = null;
    }
    // If not forcing but list is empty (initial load or previous error), clear error.
    else if (_semesters.isEmpty) {
        _error = null;
    }
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/semesters');

    try {
      print("Fetching semesters from: $url (Force Refresh: $forceRefresh)");
      final response = await http.get(
        url,
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
        },
      );

      print("Semesters API Response Status: ${response.statusCode}");

      if (response.statusCode == 200) {
        final List<dynamic> extractedData = json.decode(response.body);
        if (extractedData is List) {
          _semesters = extractedData
              .map((semesterJson) => Semester.fromJson(semesterJson as Map<String, dynamic>))
              .toList();
          _error = null; // Clear error on success
        } else {
          _error = 'Failed to load semesters: API response was not a list as expected.';
          _semesters = [];
        }
      } else {
        String errorMessage = 'Failed to load semesters. Status Code: ${response.statusCode}';
        // ... (your existing error message parsing logic) ...
        try {
          final errorData = json.decode(response.body);
          if (errorData != null && errorData['message'] != null) {
            errorMessage = errorData['message'];
            if (errorData['code'] != null) {
              errorMessage += ' (Code: ${errorData['code']})';
            }
          } else if (response.body.isNotEmpty) {
            errorMessage += "\nAPI Response: ${response.body}";
          }
        } catch (e) {
          errorMessage += "\nRaw API Response: ${response.body}";
        }
        _error = errorMessage;
      }
    } catch (e) {
      _error = 'An unexpected error occurred while fetching semesters: ${e.toString()}';
      print("Exception during fetchSemesters: $_error");
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  void clearSemesters() {
    _semesters = [];
    _error = null;
    notifyListeners();
  }
}
// lib/provider/testimonial_provider.dart
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:mgw_tutorial/models/testimonial.dart';

class TestimonialProvider with ChangeNotifier {
  List<Testimonial> _testimonials = [];
  bool _isLoading = false;
  String? _error;

  List<Testimonial> get testimonials => [..._testimonials];
  bool get isLoading => _isLoading;
  String? get error => _error;

  // API Base URL for testimonials
  static const String _apiBaseUrl = "https://mgw-backend.onrender.com/api";

  Future<void> fetchTestimonials({bool forceRefresh = false, String? statusFilter = "approved"}) async {
    if (!forceRefresh && _testimonials.isNotEmpty && !_isLoading) {
      // Optional: Add logic here if you want to avoid refetching if a specific filter was already applied
      // For now, it refetches if forceRefresh is true or list is empty/error.
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    String apiUrl = '$_apiBaseUrl/testimonials';
    if (statusFilter != null && statusFilter.isNotEmpty) {
        apiUrl += '?status=$statusFilter'; // Example: /api/testimonials?status=approved
    }

    final url = Uri.parse(apiUrl);
    print("Fetching testimonials from: $url");

    try {
      final response = await http.get(url, headers: {
        "Accept": "application/json",
      });

      print("Testimonials API Response Status: ${response.statusCode}");
      // print("Testimonials API Response Body: ${response.body}"); // For debugging

      if (response.statusCode == 200) {
        final dynamic decodedData = json.decode(response.body);
        if (decodedData is List) {
          _testimonials = decodedData
              .map((testimonialJson) {
                  try {
                    return Testimonial.fromJson(testimonialJson as Map<String, dynamic>);
                  } catch (e) {
                    print("Error parsing testimonial: $e. JSON: $testimonialJson");
                    return null; // Skip problematic items
                  }
              })
              .whereType<Testimonial>() // Filter out nulls from parsing errors
              .toList();
          // Sort by creation date, newest first
          _testimonials.sort((a, b) => b.createdAt.compareTo(a.createdAt));
          _error = null;
        } else {
          print("Testimonials API response was not a list as expected. Data: $decodedData");
          _error = 'Failed to load testimonials: Unexpected API response format.';
          _testimonials = [];
        }
      } else {
        String errorMessage = 'Failed to load testimonials. Status Code: ${response.statusCode}';
        try {
          final errorData = json.decode(response.body);
          if (errorData != null && errorData['message'] != null) {
            errorMessage = errorData['message'];
          } else if (response.body.isNotEmpty) {
            errorMessage += "\nAPI Response: ${response.body}";
          }
        } catch (e) {
          errorMessage += "\nRaw API Response: ${response.body}";
        }
        _error = errorMessage;
        print("Error fetching testimonials: $_error");
      }
    } catch (e) {
      _error = 'An unexpected error occurred while fetching testimonials: ${e.toString()}';
      print("Exception during fetchTestimonials: $_error");
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Method to allow creating a testimonial (if your app supports this)
  // This is a placeholder and needs to match your backend's requirements for POST
  Future<bool> createTestimonial({
    required String title,
    required String description,
    required int userId, // Assuming the logged-in user's ID
    List<String>? imagePaths, // For local image file paths if uploading
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    final url = Uri.parse('$_apiBaseUrl/testimonials');
    // Note: Image uploading typically requires a multipart request.
    // This example shows a simple JSON POST. Adapt if you need image uploads.
    try {
      final response = await http.post(
        url,
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          // Add Authorization header if required
          // "Authorization": "Bearer YOUR_TOKEN",
          "X-User-ID": userId.toString(), // If your backend uses this for user ID
        },
        body: json.encode({
          'title': title,
          'description': description,
          'userId': userId,
          'status': 'pending', // New testimonials likely start as pending
          'images': imagePaths ?? [], // Send empty list if no images, or handle null
        }),
      );

      _isLoading = false;
      if (response.statusCode == 201) {
        // Optionally, fetch the new testimonial or add it locally if response contains it
        fetchTestimonials(forceRefresh: true, statusFilter: null); // Refresh list (or just approved)
        notifyListeners();
        return true;
      } else {
        _error = "Failed to create testimonial: ${response.statusCode} ${response.body}";
        notifyListeners();
        return false;
      }
    } catch (e) {
      _isLoading = false;
      _error = "Error creating testimonial: ${e.toString()}";
      notifyListeners();
      return false;
    }
  }


  void clearError() {
    if (_error != null) {
      _error = null;
      notifyListeners();
    }
  }

  void clearTestimonials() {
    _testimonials = [];
    _error = null;
    notifyListeners();
  }
}
// lib/provider/theme_provider.dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeProvider with ChangeNotifier {
  static const String _themeModeKey = 'theme_mode';
  ThemeMode _themeMode = ThemeMode.system; // Default to system theme

  ThemeMode get themeMode => _themeMode;

  ThemeProvider() {
    _loadThemeMode();
  }

  Future<void> _loadThemeMode() async {
    final prefs = await SharedPreferences.getInstance();
    final String? savedTheme = prefs.getString(_themeModeKey);
    if (savedTheme != null) {
      if (savedTheme == 'light') {
        _themeMode = ThemeMode.light;
      } else if (savedTheme == 'dark') {
        _themeMode = ThemeMode.dark;
      } else {
        _themeMode = ThemeMode.system;
      }
    }
    notifyListeners();
  }

  Future<void> setThemeMode(ThemeMode mode) async {
    _themeMode = mode;
    final prefs = await SharedPreferences.getInstance();
    String themeString = 'system';
    if (mode == ThemeMode.light) {
      themeString = 'light';
    } else if (mode == ThemeMode.dark) {
      themeString = 'dark';
    }
    await prefs.setString(_themeModeKey, themeString);
    notifyListeners();
  }

  // Helper to directly toggle between light and dark for a simple switch
  Future<void> toggleTheme(bool isDarkMode) async {
    setThemeMode(isDarkMode ? ThemeMode.dark : ThemeMode.light);
  }
}


---------------------
//lib/screens
// lib/screens/account/account_screen.dart
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/screens/auth/login_screen.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:mgw_tutorial/widgets/password_form_field.dart';
import 'package:mgw_tutorial/widgets/phone_form_field.dart';

class AccountScreen extends StatefulWidget {
  const AccountScreen({super.key});

  @override
  State<AccountScreen> createState() => _AccountScreenState();
}

class _AccountScreenState extends State<AccountScreen> {
  File? _profileImageFile;
  bool _notificationsEnabled = true;
  final ImagePicker _picker = ImagePicker();

  final _changePasswordFormKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmNewPasswordController = TextEditingController();
  bool _isCurrentPasswordVisible = false;
  bool _isNewPasswordVisible = false;
  bool _isConfirmNewPasswordVisible = false;

  final _changePhoneFormKey = GlobalKey<FormState>();
  final _newPhoneController = TextEditingController();
  final _otpController = TextEditingController();
  bool _otpRequested = false;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmNewPasswordController.dispose();
    _newPhoneController.dispose();
    _otpController.dispose();
    super.dispose();
  }

  Future<void> _changeProfilePicture() async {
    if (!mounted) return;
    final l10n = AppLocalizations.of(context)!;
    try {
      final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery);
      if (pickedFile != null) {
        if (mounted) {
          setState(() {
            _profileImageFile = File(pickedFile.path);
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.profilePictureSelectedMessage)),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.errorPickingImage(e.toString()))),
        );
      }
    }
  }

  void _showChangePasswordDialog() {
    final l10n = AppLocalizations.of(context)!;
    _currentPasswordController.clear();
    _newPasswordController.clear();
    _confirmNewPasswordController.clear();
    setState(() {
      _isCurrentPasswordVisible = false;
      _isNewPasswordVisible = false;
      _isConfirmNewPasswordVisible = false;
    });

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (BuildContext context, StateSetter setDialogState) {
            final authProvider = Provider.of<AuthProvider>(context, listen: false);
            return AlertDialog(
              title: Text(l10n.changePasswordNotImplementedMessage.split(" ")[0] + " " + l10n.accountPasswordLabel),
              content: Form(
                key: _changePasswordFormKey,
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: <Widget>[
                      PasswordFormField(
                        controller: _currentPasswordController,
                        isPasswordVisible: _isCurrentPasswordVisible,
                        onToggleVisibility: () => setDialogState(() => _isCurrentPasswordVisible = !_isCurrentPasswordVisible),
                        labelText: l10n.appTitle.contains("መጂወ") ? "የአሁኑ የይለፍ ቃል" : "Current Password",
                        hintText: "",
                        l10n: l10n,
                        validator: (value) {
                          if (value == null || value.isEmpty) return l10n.passwordValidationErrorRequired;
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      PasswordFormField(
                        controller: _newPasswordController,
                        isPasswordVisible: _isNewPasswordVisible,
                        onToggleVisibility: () => setDialogState(() => _isNewPasswordVisible = !_isNewPasswordVisible),
                        labelText: l10n.appTitle.contains("መጂወ") ? "አዲስ የይለፍ ቃል" : "New Password",
                        hintText: "",
                        l10n: l10n,
                         validator: (value) {
                          if (value == null || value.isEmpty) return l10n.passwordValidationErrorRequired;
                          if (value.length < 6) return l10n.passwordValidationErrorLength;
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                       PasswordFormField(
                        controller: _confirmNewPasswordController,
                        isPasswordVisible: _isConfirmNewPasswordVisible,
                        onToggleVisibility: () => setDialogState(() => _isConfirmNewPasswordVisible = !_isConfirmNewPasswordVisible),
                        labelText: l10n.appTitle.contains("መጂወ") ? "አዲስ የይለፍ ቃል አረጋግጥ" : "Confirm New Password",
                        hintText: "",
                        l10n: l10n,
                        validator: (value) {
                          if (value == null || value.isEmpty) return l10n.passwordValidationErrorRequired;
                          if (value != _newPasswordController.text) return l10n.appTitle.contains("መጂወ") ? "የይለፍ ቃሎች አይዛመዱም" : "Passwords do not match";
                          return null;
                        },
                      ),
                    ],
                  ),
                ),
              ),
              actions: <Widget>[
                TextButton(
                  child: Text(l10n.appTitle.contains("መጂወ") ? "ሰርዝ" : "Cancel"),
                  onPressed: authProvider.isLoading ? null : () => Navigator.of(ctx).pop(),
                ),
                ElevatedButton(
                  onPressed: authProvider.isLoading ? null : () async {
                    if (_changePasswordFormKey.currentState!.validate()) {
                      final result = await authProvider.changePassword(
                        currentPassword: _currentPasswordController.text,
                        newPassword: _newPasswordController.text,
                      );
                      if (mounted) {
                         Navigator.of(ctx).pop(); 
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text(result['message'] ?? "An error occurred."),
                            backgroundColor: result['success'] ? Colors.green : Colors.red,
                          ),
                        );
                      }
                    }
                  },
                  child: authProvider.isLoading 
                      ? const SizedBox(height: 20, width: 20, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation(Colors.white))) 
                      : Text(l10n.changeButton),
                ),
              ],
            );
          }
        );
      },
    );
  }

  void _showChangePhoneDialog() {
    final l10n = AppLocalizations.of(context)!;
    _newPhoneController.clear();
    _otpController.clear();
    setState(() {
      _otpRequested = false;
    });

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (BuildContext context, StateSetter setDialogState) {
            final authProvider = Provider.of<AuthProvider>(context, listen: false);
            return AlertDialog(
              title: Text(l10n.changePhoneNumberNotImplementedMessage.split(" ")[0] + " " + l10n.phoneNumberLabel),
              content: Form(
                key: _changePhoneFormKey,
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: <Widget>[
                      if (!_otpRequested)
                        PhoneFormField(
                          controller: _newPhoneController,
                          labelText: l10n.appTitle.contains("መጂወ") ? "አዲስ ስልክ ቁጥር" : "New Phone Number",
                          hintText: l10n.phoneNumberHint,
                          l10n: l10n,
                          validator: (value) {
                            if (value == null || value.isEmpty) return l10n.phoneNumberValidationErrorRequired;
                            final normalizedInput = authProvider.normalizePhoneNumberToE164('0$value'); // Assuming 9 digits input
                            final currentUserPhone = authProvider.currentUser?.phone;
                            if (!RegExp(r'^[0-9]{9}$').hasMatch(value)){ // Check if it's 9 digits
                               return l10n.phoneNumberValidationErrorInvalid;
                            }
                            if (currentUserPhone != null && normalizedInput == currentUserPhone) {
                                return l10n.appTitle.contains("መጂወ") ? "አዲስ ስልክ ቁጥር ከአሁኑ ጋር አንድ መሆን የለበትም" : "New phone number cannot be the same as current.";
                            }
                            return null;
                          },
                        )
                      else
                        TextFormField(
                          controller: _otpController,
                          decoration: InputDecoration(labelText: l10n.appTitle.contains("መጂወ") ? "OTP ያስገቡ" : "Enter OTP"),
                          keyboardType: TextInputType.number,
                          validator: (value) {
                            if (value == null || value.isEmpty) return l10n.appTitle.contains("መጂወ") ? "እባክዎ OTP ያስገቡ" : "Please enter OTP";
                            if (value.length != 6) return l10n.appTitle.contains("መጂወ") ? "OTP 6 አሃዝ መሆን አለበት" : "OTP must be 6 digits";
                            return null;
                          },
                        ),
                    ],
                  ),
                ),
              ),
              actions: <Widget>[
                TextButton(
                  child: Text(l10n.appTitle.contains("መጂወ") ? "ሰርዝ" : "Cancel"),
                  onPressed: authProvider.isLoading ? null : () => Navigator.of(ctx).pop(),
                ),
                ElevatedButton(
                  onPressed: authProvider.isLoading ? null : () async {
                    if (_changePhoneFormKey.currentState!.validate()) {
                      if (!_otpRequested) {
                        setDialogState(() {}); 
                        final result = await authProvider.requestPhoneChangeOTP(
                          newRawPhoneNumber: _newPhoneController.text, // Send raw 9 digits
                        );
                        if (mounted) {
                           if (result['success']) {
                            setDialogState(() { _otpRequested = true; });
                            ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(result['message']!), backgroundColor: Colors.green,));
                          } else {
                            ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(result['message']!), backgroundColor: Colors.red,));
                          }
                        }
                      } else { 
                        setDialogState(() {});
                        final result = await authProvider.verifyOtpAndChangePhone(
                          newRawPhoneNumber: _newPhoneController.text, // Send raw 9 digits
                          otp: _otpController.text,
                        );
                        if (mounted) {
                          Navigator.of(ctx).pop(); 
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(result['message'] ?? "An error occurred."),
                              backgroundColor: result['success'] ? Colors.green : Colors.red,
                            ),
                          );
                          if (result['success']) {
                            setState(() {}); 
                          }
                        }
                      }
                    }
                  },
                  child: authProvider.isLoading
                    ? const SizedBox(height: 20, width: 20, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation(Colors.white)))
                    : Text(_otpRequested ? (l10n.appTitle.contains("መጂወ") ? "OTP አረጋግጥ" : "Verify OTP") : (l10n.appTitle.contains("መጂወ") ? "OTP ጠይቅ" : "Request OTP")),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _handleLogout() async {
    if (!mounted) return;
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final l10n = AppLocalizations.of(context)!;
    await authProvider.logout();
    if (mounted) {
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const LoginScreen()),
        (Route<dynamic> route) => false,
      );
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.logoutSuccess)),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;
    final authProvider = Provider.of<AuthProvider>(context);
    final currentUser = authProvider.currentUser;

    String displayName = l10n.guestUser;
    String displayPhone = "";
    String? userProfileNetworkUrl;

    if (currentUser != null) {
      displayName = ('${currentUser.firstName} ${currentUser.lastName}').trim();
      if (displayName.isEmpty) {
        displayName = currentUser.phone;
      }
      displayPhone = currentUser.phone;
      // userProfileNetworkUrl = currentUser.profileImageUrl; // If you add this
    }

    Widget profilePictureWidget;
    if (_profileImageFile != null) {
      profilePictureWidget = CircleAvatar(
        radius: 60,
        backgroundImage: FileImage(_profileImageFile!),
        backgroundColor: theme.colorScheme.surfaceVariant,
      );
    } else if (userProfileNetworkUrl != null && userProfileNetworkUrl.isNotEmpty) {
      profilePictureWidget = CircleAvatar(
        radius: 60,
        backgroundImage: NetworkImage(userProfileNetworkUrl),
        backgroundColor: theme.colorScheme.surfaceVariant,
      );
    } else {
      profilePictureWidget = CircleAvatar(
        radius: 60,
        backgroundColor: theme.colorScheme.primaryContainer,
        child: Icon(
          Icons.person,
          size: 70,
          color: theme.colorScheme.onPrimaryContainer,
        ),
      );
    }

    if (currentUser == null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(l10n.pleaseLoginOrRegister, style: theme.textTheme.titleLarge),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () {
                Navigator.of(context).pushAndRemoveUntil(
                  MaterialPageRoute(builder: (context) => const LoginScreen()),
                  (route) => false);
              },
              child: Text(l10n.signInLink),
            )
          ],
        ),
      );
    }

    return Scaffold(
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            const SizedBox(height: 20),
            Center(
              child: Column(
                children: [
                  profilePictureWidget,
                  const SizedBox(height: 8),
                  Text(displayName, style: theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold)),
                  if (displayPhone.isNotEmpty)
                     Text(displayPhone, style: theme.textTheme.titleMedium?.copyWith(color: theme.colorScheme.onSurface.withOpacity(0.7))),
                  const SizedBox(height: 12),
                  TextButton.icon(
                    icon: const Icon(Icons.edit_outlined, size: 20),
                    label: Text(l10n.changeProfilePictureButton),
                    onPressed: _changeProfilePicture,
                    style: TextButton.styleFrom(foregroundColor: theme.colorScheme.primary),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 30),
            _buildInfoCard(
              context: context,
              l10n: l10n,
              label: l10n.accountPhoneNumberLabel,
              value: displayPhone.isNotEmpty ? displayPhone : l10n.appTitle.contains("መጂወ") ? "ስልክ አልተገኘም" : "Phone not available",
              onChange: _showChangePhoneDialog,
            ),
            const SizedBox(height: 16),
            _buildInfoCard(
              context: context,
              l10n: l10n,
              label: l10n.accountPasswordLabel,
              value: '••••••••••',
              onChange: _showChangePasswordDialog,
            ),
            const SizedBox(height: 30),
            Card(
              elevation: 2.0,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
              child: SwitchListTile(
                title: Text(
                  l10n.notificationsLabel,
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
                ),
                value: _notificationsEnabled,
                onChanged: (bool value) {
                  setState(() {
                    _notificationsEnabled = value;
                  });
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text(value ? l10n.notificationsEnabledMessage : l10n.notificationsDisabledMessage)),
                  );
                },
                activeColor: theme.colorScheme.primary,
                contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
              ),
            ),
            const SizedBox(height: 40),
            // CORRECTED LOGOUT BUTTON
            ElevatedButton.icon(
              icon: Icon(Icons.logout, color: theme.colorScheme.onError),
              label: Text(l10n.logout, style: TextStyle(color: theme.colorScheme.onError)),
              onPressed: _handleLogout, // <<< ADDED onPressed
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.colorScheme.error, 
                foregroundColor: theme.colorScheme.onError, 
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoCard({
    required BuildContext context,
    required AppLocalizations l10n,
    required String label,
    required String value,
    required VoidCallback onChange,
  }) {
    final theme = Theme.of(context);
    return Card(
      elevation: 2.0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: <Widget>[
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.6)
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    value,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w500,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
            TextButton(
              onPressed: onChange,
              style: TextButton.styleFrom(
                foregroundColor: theme.colorScheme.onPrimary,
                backgroundColor: theme.colorScheme.primary,
                padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 8.0),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(6.0),
                ),
              ),
              child: Text(l10n.changeButton),
            ),
          ],
        ),
      ),
    );
  }
}
// lib/screens/auth/login_screen.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/screens/main_screen.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/locale_provider.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:mgw_tutorial/screens/registration/registration_screen.dart';
// Widgets
import 'package:mgw_tutorial/widgets/auth/auth_screen_header.dart';
import 'package:mgw_tutorial/widgets/auth/auth_card_wrapper.dart';
import 'package:mgw_tutorial/widgets/auth/auth_form_title.dart';
import 'package:mgw_tutorial/widgets/auth/auth_navigation_link.dart';
import 'package:mgw_tutorial/widgets/phone_form_field.dart';
import 'package:mgw_tutorial/widgets/password_form_field.dart';
// Import DeviceInfoService
import 'package:mgw_tutorial/services/device_info.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();

  // MODIFIED: Removed 'ti' (Tigrigna)
  final List<String> _supportedLanguageCodes = ['en', 'am', 'or'];
  bool _isPasswordVisible = false;

  final DeviceInfoService _deviceInfoService = DeviceInfoService();
  String _deviceInfoString = 'Fetching device info...';

  @override
  void initState() {
    super.initState();
    _getDeviceInfo();
  }

  Future<void> _getDeviceInfo() async {
    // await WidgetsFlutterBinding.ensureInitialized(); // Usually not needed here
    if (!mounted) return;

    final deviceData = await _deviceInfoService.getDeviceData();
    String brand = deviceData['brand'] ?? deviceData['name'] ?? 'UnknownBrand';
    String model = deviceData['model'] ?? deviceData['localizedModel'] ?? 'UnknownModel';
    String os = deviceData['systemName'] ?? deviceData['platform'] ?? 'UnknownOS';
    String deviceType = _deviceInfoService.detectDeviceType(context);


    if (mounted) {
      setState(() {
        _deviceInfoString = '$deviceType - $brand $model, $os';
        print("Device Info for Login: $_deviceInfoString");
      });
    }
  }

  @override
  void dispose() {
    _phoneController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _togglePasswordVisibility() {
    setState(() {
      _isPasswordVisible = !_isPasswordVisible;
    });
  }

  Future<void> _handleLogin() async {
    final l10n = AppLocalizations.of(context)!;
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    authProvider.clearError();

    if (_formKey.currentState!.validate()) {
      String rawPhoneInput = _phoneController.text.trim();
      String loginPhoneNumber;

      if (rawPhoneInput.isEmpty) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.phoneNumberValidationErrorRequired)),
          );
        }
        return;
      }

      if (rawPhoneInput.startsWith('+251') && rawPhoneInput.length == 13) {
        loginPhoneNumber = rawPhoneInput;
      } else if (rawPhoneInput.length == 9 && !rawPhoneInput.startsWith('0')) {
        loginPhoneNumber = '+251$rawPhoneInput';
      } else if (rawPhoneInput.startsWith('0') && rawPhoneInput.length == 10) {
        loginPhoneNumber = '+251${rawPhoneInput.substring(1)}';
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.phoneNumberValidationErrorInvalid)),
          );
        }
        return;
      }


      final String password = _passwordController.text;

      if (_deviceInfoString == 'Fetching device info...' || _deviceInfoString.isEmpty) {
        await _getDeviceInfo();
        if (_deviceInfoString == 'Fetching device info...' || _deviceInfoString.isEmpty) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text("Device information not available. Please wait and try again.")),
            );
          }
          return;
        }
      }

      print("Attempting login with Phone: $loginPhoneNumber, Password: [HIDDEN], Device: $_deviceInfoString");

      bool success = await authProvider.login(
        phoneNumber: loginPhoneNumber,
        password: password,
        deviceInfo: _deviceInfoString,
      );

      if (mounted) {
        if (success) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.loginSuccessMessage)),
          );
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => const MainScreen()),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(authProvider.apiError?.message ?? l10n.signInFailedErrorGeneral),
              backgroundColor: Colors.redAccent,
            ),
          );
        }
      }
    }
  }

  String _getLanguageDisplayName(String langCode, AppLocalizations l10n) {
    switch (langCode) {
      case 'en':
        return l10n.english;
      case 'am':
        return l10n.amharic;
      case 'or':
        return l10n.afaanOromo;
      case 'ti': // This case will no longer be hit from the dropdown
        return l10n.tigrigna;
      default:
        return langCode.toUpperCase();
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final authProvider = Provider.of<AuthProvider>(context);
    final localeProvider = Provider.of<LocaleProvider>(context);

    String currentLanguageCode = localeProvider.locale?.languageCode ?? 'en';
    // If the saved locale (e.g. 'ti') is no longer supported, default to the first available.
    if (!_supportedLanguageCodes.contains(currentLanguageCode)) {
      currentLanguageCode = _supportedLanguageCodes.isNotEmpty ? _supportedLanguageCodes.first : 'en';
      // Optionally, update the provider if the current locale is invalid
      // WidgetsBinding.instance.addPostFrameCallback((_) {
      //   if (localeProvider.locale?.languageCode != currentLanguageCode) {
      //     localeProvider.setLocale(Locale(currentLanguageCode));
      //   }
      // });
    }

    return Scaffold(
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              Align(
                alignment: Alignment.topRight,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 0),
                  decoration: BoxDecoration(
                    color: Theme.of(context).canvasColor,
                    borderRadius: BorderRadius.circular(8.0),
                    border: Border.all(color: Colors.grey[400] ?? Colors.grey),
                  ),
                  // The DropdownButton is back here
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: currentLanguageCode,
                      icon: Icon(Icons.arrow_drop_down, color: Theme.of(context).primaryColor),
                      elevation: 2,
                      style: TextStyle(color: Theme.of(context).textTheme.bodyLarge?.color ?? Colors.black, fontSize: 14),
                      dropdownColor: Theme.of(context).cardColor,
                      onChanged: (String? newLanguageCode) {
                        if (newLanguageCode != null) {
                          localeProvider.setLocale(Locale(newLanguageCode));
                        }
                      },
                      items: _supportedLanguageCodes // This list no longer contains 'ti'
                          .map<DropdownMenuItem<String>>((String langCode) {
                        return DropdownMenuItem<String>(
                          value: langCode,
                          child: Text(_getLanguageDisplayName(langCode, l10n)),
                        );
                      }).toList(),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 20),
              AuthScreenHeader(
                title: l10n.mgwTutorialTitle,
                subtitle: l10n.loginToContinue,
              ),
              const SizedBox(height: 40),
              AuthCardWrapper(
                child: Form(
                  key: _formKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: <Widget>[
                      AuthFormTitle(title: l10n.loginTitle),
                      const SizedBox(height: 24),
                      PhoneFormField(
                        controller: _phoneController,
                        l10n: l10n,
                      ),
                      const SizedBox(height: 20),
                      PasswordFormField(
                        controller: _passwordController,
                        isPasswordVisible: _isPasswordVisible,
                        onToggleVisibility: _togglePasswordVisibility,
                        l10n: l10n,
                      ),
                      const SizedBox(height: 30),
                      authProvider.isLoading
                          ? const Center(child: CircularProgressIndicator())
                          : ElevatedButton(
                              onPressed: _handleLogin,
                              child: Text(l10n.signInButton),
                            ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              AuthNavigationLink(
                leadingText: l10n.dontHaveAccount,
                linkText: l10n.signUpLinkText,
                onLinkPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (context) => const RegistrationScreen()),
                  );
                },
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }
}
//lib/screens/home/home_screen.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/widgets/home/semesters_card.dart';
import 'package:mgw_tutorial/widgets/home/notes_card.dart';
import 'package:mgw_tutorial/provider/semester_provider.dart';
import 'package:provider/provider.dart';
// import 'package:mgw_tutorial/screens/library/library_screen.dart'; // Not used in this snippet
import 'package:mgw_tutorial/screens/registration/registration_screen.dart'; // Ensure this path is correct
import 'package:mgw_tutorial/models/semester.dart'; // Import the Semester model

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  @override
  void initState() {
    super.initState();
    // Fetch semesters when the screen is initialized
    // Use listen:false because we are in initState
    Future.microtask(() =>
        Provider.of<SemesterProvider>(context, listen: false).fetchSemesters());
  }

  void _navigateToRegistrationForm() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const RegistrationScreen()),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // appBar: AppBar( // Optional: Add an AppBar if your design needs one for HomeScreen
      //   title: const Text('Home'),
      // ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Consumer<SemesterProvider>(
              builder: (context, semesterProvider, child) {
                if (semesterProvider.isLoading) {
                  // Show a loading indicator that doesn't take up the whole screen initially
                  // or a more specific shimmer effect for the card area if preferred.
                  return const Padding(
                    padding: EdgeInsets.symmetric(vertical: 50.0),
                    child: Center(child: CircularProgressIndicator()),
                  );
                }
                if (semesterProvider.error != null) {
                  return Center(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            // Using semesterProvider.error directly as it's formatted in provider
                            '${semesterProvider.error}',
                            textAlign: TextAlign.center,
                            style: TextStyle(color: Colors.red[700]),
                          ),
                          const SizedBox(height: 10),
                          ElevatedButton(
                            onPressed: () => semesterProvider.fetchSemesters(),
                            child: const Text('Retry'),
                          )
                        ],
                      ),
                    ),
                  );
                }
                if (semesterProvider.semesters.isEmpty) {
                  return const Center(
                      child: Padding(
                        padding: EdgeInsets.symmetric(vertical: 50.0),
                        child: Text('No semesters available at the moment.',
                            style: TextStyle(fontSize: 16)),
                      ));
                }

                // If data is available, build the list of SemestersCard
                return Column(
                  children: semesterProvider.semesters.map((semester) {
                    // Prepare subjects for the card
                    List<String> subjectsLeft = [];
                    List<String> subjectsRight = [];
                    for (int i = 0; i < semester.courses.length; i++) {
                      if (i.isEven) {
                        subjectsLeft.add(semester.courses[i].name);
                      } else {
                        subjectsRight.add(semester.courses[i].name);
                      }
                    }
                    // If no courses, provide a default message or leave empty
                    if (semester.courses.isEmpty) {
                      subjectsLeft.add("Courses details coming soon.");
                    }

                    return Padding(
                      padding: const EdgeInsets.only(bottom: 16.0),
                      child: SemestersCard(
                        title: '${semester.name} - ${semester.year}',
                        // Use the helper getter from Semester model
                        // Provide a fallback URL if firstImageUrl is null
                        imageUrl: semester.firstImageUrl ?? 'https://via.placeholder.com/600x300.png?text=Semester+Image',
                        subjectsLeft: subjectsLeft,
                        subjectsRight: subjectsRight,
                        price: semester.price, // Assuming price is a string like "150.00"
                        onTap: () {
                           // Example: Navigate to a SemesterDetailScreen
                           // Navigator.of(context).push(MaterialPageRoute(builder: (_) => SemesterDetailScreen(semester: semester)));
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(content: Text('${semester.name} (ID: ${semester.id}) Tapped')),
                          );
                           print('Tapped on semester: ${semester.name}, ID: ${semester.id}');
                        },
                      ),
                    );
                  }).toList(),
                );
              },
            ),
            const SizedBox(height: 16),
            // Assuming NotesCard takes a full URL or you have a placeholder/asset
            const NotesCard(
              title: 'Notes',
              description: 'Notes we have collected from students all around the country.',
              imageUrl: 'https://via.placeholder.com/600x200.png?text=Notes+Preview', // Placeholder
            ),
            const SizedBox(height: 24),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text(
                'Join over 4,000 students who are already boosting their grades',
                textAlign: TextAlign.center,
                style: TextStyle(
                  fontSize: 16,
                  color: Colors.grey[800],
                ),
              ),
            ),
            
            const SizedBox(height: 20), // For some spacing at the bottom
          ],
        ),
      ),
    );
  }
}
// lib/screens/library/chapter_detail_screen.dart
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart'; // For opening PDFs or external video links

// You might want to create models for Video, PDF, Exam if they become complex
// For now, we'll use Maps as in your _allSubjectChaptersData structure

class ChapterDetailScreen extends StatelessWidget {
  static const routeName = '/chapter-detail';

  final String subjectTitle;
  final Map<String, dynamic> chapter; // Contains chapter id, title, and content links/data

  const ChapterDetailScreen({
    super.key,
    required this.subjectTitle,
    required this.chapter,
  });

  // Helper to launch URLs
  Future<void> _launchUrl(BuildContext context, String urlString) async {
    final Uri uri = Uri.parse(urlString);
    if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Could not launch $urlString')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Extract content from the chapter map. Provide empty lists as fallbacks.
    // The structure here should match what you have in _allSubjectChaptersData
    // or what your API returns for chapter details.

    // Example: Assuming 'videos' is a List<Map<String, String>> with 'title' and 'url' or 'description'
    final List<dynamic> videosRaw = chapter['videos'] as List<dynamic>? ?? [];
    final List<Map<String, String>> videos = videosRaw.map((v) {
      if (v is Map) {
        return {
          'title': v['title']?.toString() ?? 'Untitled Video',
          'description': v['description']?.toString() ?? '',
          'url': v['url']?.toString(), // Optional: if you have direct video URLs
        };
      }
      return {'title': 'Invalid Video Data', 'description': ''};
    }).toList();

    // Example: Assuming 'notes' is a String or a Map with 'content'
    final String notesContent = (chapter['notes'] is String
            ? chapter['notes']
            : (chapter['notes'] is Map ? chapter['notes']['content']?.toString() : null)) ??
        'No notes available for this chapter yet.';

    // Example: Assuming 'pdfs' is a List<Map<String, String>> with 'title' and 'url'
    final List<dynamic> pdfsRaw = chapter['pdfs'] as List<dynamic>? ?? [];
    final List<Map<String, String>> pdfs = pdfsRaw.map((p) {
      if (p is Map) {
        return {
          'title': p['title']?.toString() ?? 'Untitled PDF',
          'url': p['url']?.toString() ?? '', // PDF URL is important
        };
      }
      return {'title': 'Invalid PDF Data', 'url': ''};
    }).toList();

    // Example: Assuming 'exams' is a List<Map<String, dynamic>> with 'title' and 'questionCount'
    final List<dynamic> examsRaw = chapter['exams'] as List<dynamic>? ?? [];
    final List<Map<String, dynamic>> exams = examsRaw.map((e) {
      if (e is Map) {
        return {
          'title': e['title']?.toString() ?? 'Untitled Exam',
          'questionCount': e['questionCount'] as int?,
          'id': e['id']?.toString(), // Optional: if you navigate to an exam by ID
        };
      }
      return {'title': 'Invalid Exam Data'};
    }).toList();

    return DefaultTabController(
      length: 4, // Number of tabs: Videos, Notes, PDF, Exams
      child: Scaffold(
        appBar: AppBar(
          title: Text('${chapter['title'] ?? 'Chapter Details'}'),
          // If subjectTitle is important to show: Text('$subjectTitle - ${chapter['title'] ?? 'Chapter'}'),
          bottom: const TabBar(
            isScrollable: false, // Set to true if tab labels are long or many
            labelColor: Colors.blue, // Or Theme.of(context).primaryColor
            unselectedLabelColor: Colors.grey,
            indicatorColor: Colors.blue, // Or Theme.of(context).primaryColor
            tabs: [
              Tab(icon: Icon(Icons.videocam_outlined), text: 'Videos'),
              Tab(icon: Icon(Icons.notes_outlined), text: 'Notes'),
              Tab(icon: Icon(Icons.picture_as_pdf_outlined), text: 'PDF'),
              Tab(icon: Icon(Icons.quiz_outlined), text: 'Exams'),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            _buildVideoList(context, videos),
            _buildNotesView(context, notesContent),
            _buildPdfList(context, pdfs),
            _buildExamList(context, exams),
          ],
        ),
      ),
    );
  }

  // Widget builder for the Videos Tab
  Widget _buildVideoList(BuildContext context, List<Map<String, String>> videos) {
    if (videos.isEmpty) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.video_library_outlined, size: 60, color: Colors.grey),
            SizedBox(height: 16),
            Text('No videos available for this chapter yet.', style: TextStyle(fontSize: 16, color: Colors.grey)),
          ],
        ),
      );
    }
    return ListView.builder(
      padding: const EdgeInsets.all(8.0),
      itemCount: videos.length,
      itemBuilder: (ctx, index) {
        final video = videos[index];
        return Card(
          elevation: 2,
          margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          child: ListTile(
            leading: Icon(Icons.play_circle_fill_rounded, color: Theme.of(context).primaryColor, size: 40),
            title: Text(video['title']!, style: const TextStyle(fontWeight: FontWeight.w500)),
            subtitle: video['description']!.isNotEmpty ? Text(video['description']!) : null,
            onTap: () {
              // TODO: Implement video player
              // If video['url'] is a direct link, you could use url_launcher
              // or navigate to a dedicated video player screen.
              if (video['url'] != null && video['url']!.isNotEmpty) {
                 _launchUrl(context, video['url']!);
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('Video player for "${video['title']}" not implemented yet.')),
                );
              }
            },
          ),
        );
      },
    );
  }

  // Widget builder for the Notes Tab
  Widget _buildNotesView(BuildContext context, String notesContent) {
    if (notesContent == 'No notes available for this chapter yet.') {
       return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.text_snippet_outlined, size: 60, color: Colors.grey),
            SizedBox(height: 16),
            Text('No notes available for this chapter yet.', style: TextStyle(fontSize: 16, color: Colors.grey)),
          ],
        ),
      );
    }
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Text(
        notesContent,
        style: const TextStyle(fontSize: 16, height: 1.5, color: Colors.black87),
      ),
    );
  }

  // Widget builder for the PDF Tab
  Widget _buildPdfList(BuildContext context, List<Map<String, String>> pdfs) {
    if (pdfs.isEmpty) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.picture_as_pdf_outlined, size: 60, color: Colors.grey),
            SizedBox(height: 16),
            Text('No PDFs available for this chapter yet.', style: TextStyle(fontSize: 16, color: Colors.grey)),
          ],
        ),
      );
    }
    return ListView.builder(
      padding: const EdgeInsets.all(8.0),
      itemCount: pdfs.length,
      itemBuilder: (ctx, index) {
        final pdf = pdfs[index];
        return Card(
          elevation: 2,
          margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          child: ListTile(
            leading: Icon(Icons.description_outlined, color: Colors.redAccent[700], size: 40),
            title: Text(pdf['title']!, style: const TextStyle(fontWeight: FontWeight.w500)),
            trailing: const Icon(Icons.arrow_forward_ios, size: 16),
            onTap: () {
              if (pdf['url'] != null && pdf['url']!.isNotEmpty) {
                _launchUrl(context, pdf['url']!); // Uses url_launcher to open PDF URL
              } else {
                 ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('PDF link for "${pdf['title']}" is missing.')),
                );
              }
            },
          ),
        );
      },
    );
  }

  // Widget builder for the Exams Tab
  Widget _buildExamList(BuildContext context, List<Map<String, dynamic>> exams) {
    if (exams.isEmpty) {
       return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.quiz_outlined, size: 60, color: Colors.grey),
            SizedBox(height: 16),
            Text('No exams available for this chapter yet.', style: TextStyle(fontSize: 16, color: Colors.grey)),
          ],
        ),
      );
    }
    return ListView.builder(
      padding: const EdgeInsets.all(8.0),
      itemCount: exams.length,
      itemBuilder: (ctx, index) {
        final exam = exams[index];
        return Card(
          elevation: 2,
          margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          child: ListTile(
            leading: Icon(Icons.assignment_turned_in_outlined, color: Colors.green[700], size: 40),
            title: Text(exam['title']!, style: const TextStyle(fontWeight: FontWeight.w500)),
            subtitle: exam['questionCount'] != null ? Text('Questions: ${exam['questionCount']}') : null,
            trailing: const Icon(Icons.arrow_forward_ios, size: 16),
            onTap: () {
              // TODO: Implement navigation to the exam taking screen
              // You might pass exam['id'] or the whole exam map
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Exam screen for "${exam['title']}" not implemented yet.')),
              );
            },
          ),
        );
      },
    );
  }
}
// lib/screens/library/course_sections_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/models/api_course.dart';
import 'package:mgw_tutorial/models/section.dart'; // Import Section model
import 'package:mgw_tutorial/provider/section_provider.dart'; // Import SectionProvider
import 'package:mgw_tutorial/screens/library/lesson_list_screen.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';


class CourseSectionsScreen extends StatefulWidget {
  static const routeName = '/course-sections';
  final ApiCourse course; // Still receives the ApiCourse to know which course's sections to fetch

  const CourseSectionsScreen({super.key, required this.course});

  @override
  State<CourseSectionsScreen> createState() => _CourseSectionsScreenState();
}

class _CourseSectionsScreenState extends State<CourseSectionsScreen> {
  @override
  void initState() {
    super.initState();
    // Fetch sections when the screen initializes
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Provider.of<SectionProvider>(context, listen: false)
          .fetchSectionsForCourse(widget.course.id);
    });
  }

  Future<void> _refreshSections() async {
    await Provider.of<SectionProvider>(context, listen: false)
        .fetchSectionsForCourse(widget.course.id, forceRefresh: true);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final sectionProvider = Provider.of<SectionProvider>(context);
    final List<Section> sections = sectionProvider.sectionsForCourse(widget.course.id);
    final bool isLoading = sectionProvider.isLoadingForCourse(widget.course.id);
    final String? error = sectionProvider.errorForCourse(widget.course.id);

    return Scaffold(
      appBar: AppBar(
        title: Text(widget.course.title.isNotEmpty ? widget.course.title : l10n.appTitle.contains("መጂወ") ? "ምዕራፎች" : "Chapters"),
      ),
      body: RefreshIndicator(
        onRefresh: _refreshSections,
        child: Builder(
          builder: (context) {
            if (isLoading && sections.isEmpty) {
              return const Center(child: CircularProgressIndicator());
            }
            if (error != null && sections.isEmpty) {
              return Center(
                child: Padding(
                  padding: const EdgeInsets.all(20.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.error_outline, color: theme.colorScheme.error, size: 50),
                      const SizedBox(height: 16),
                      Text(
                        l10n.appTitle.contains("መጂወ") ? "ምዕራፎችን መጫን አልተሳካም።\n$error" : "Failed to load chapters.\n$error",
                        textAlign: TextAlign.center,
                        style: TextStyle(color: theme.colorScheme.onSurface.withOpacity(0.7)),
                      ),
                      const SizedBox(height: 20),
                      ElevatedButton.icon(
                        icon: const Icon(Icons.refresh),
                        label: Text(l10n.refresh),
                        onPressed: _refreshSections,
                      )
                    ],
                  ),
                ),
              );
            }
            if (sections.isEmpty && !isLoading) {
              return Center(
                child: Padding(
                  padding: const EdgeInsets.all(20.0),
                  child: Text(
                    l10n.appTitle.contains("መጂወ") ? "ለዚህ ኮርስ ምንም ምዕራፎች አልተገኙም።" : "No chapters found for this course.",
                    textAlign: TextAlign.center,
                    style: theme.textTheme.titleMedium,
                  ),
                ),
              );
            }

            return ListView.builder(
              padding: const EdgeInsets.all(8.0),
              itemCount: sections.length,
              itemBuilder: (ctx, index) {
                final section = sections[index];
                return Card(
                  margin: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 8.0),
                  elevation: 2.5,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                  child: ListTile(
                    contentPadding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
                    leading: CircleAvatar(
                      backgroundColor: theme.colorScheme.primaryContainer,
                      foregroundColor: theme.colorScheme.onPrimaryContainer,
                      child: Text('${section.order ?? index + 1}'),
                    ),
                    title: Text(
                      section.title,
                      style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500),
                    ),
                    trailing: Icon(Icons.arrow_forward_ios, size: 16, color: theme.iconTheme.color?.withOpacity(0.6)),
                    onTap: () {
                      Navigator.pushNamed(
                        context,
                        LessonListScreen.routeName,
                        arguments: section, // <<< PASS THE ACTUAL Section OBJECT
                      );
                      print('Tapped on section: ${section.title} (ID: ${section.id})');
                    },
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }
}
// lib/screens/library/lesson_list_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/models/lesson.dart';
import 'package:mgw_tutorial/provider/lesson_provider.dart';
import 'package:mgw_tutorial/models/section.dart'; // To receive Section object
import 'package:url_launcher/url_launcher.dart'; // For opening links
import 'package:flutter_gen/gen_l10n/app_localizations.dart';


class LessonListScreen extends StatefulWidget {
  static const routeName = '/lesson-list';

  final Section section; // <<< ACCEPTS A Section OBJECT

  const LessonListScreen({
    super.key,
    required this.section,
  });

  @override
  State<LessonListScreen> createState() => _LessonListScreenState();
}

class _LessonListScreenState extends State<LessonListScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  // For now, we'll have 2 tabs: Lessons (combined) and maybe a placeholder for Quizzes if your Lesson model differentiates.
  // Let's simplify to one "Content" tab that lists all lessons.
  // If your LessonType enum (video, document, quiz, text) is well-defined in the model,
  // you can use that to decide how to render each lesson item.

  @override
  void initState() {
    super.initState();
    // If you want tabs for different lesson types, adjust length here.
    // For simplicity, starting with one list of all lessons.
    // _tabController = TabController(length: 1, vsync: this); // Example: One tab for "Lessons"
    _tabController = TabController(length: 4, vsync: this); // Videos, Notes, PDF, Exams (from your old mock structure)


    WidgetsBinding.instance.addPostFrameCallback((_) {
      Provider.of<LessonProvider>(context, listen: false)
          .fetchLessonsForSection(widget.section.id);
    });
    print("LessonListScreen for section: ${widget.section.title} (ID: ${widget.section.id})");
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
  
  Future<void> _refreshLessons() async {
     await Provider.of<LessonProvider>(context, listen: false)
          .fetchLessonsForSection(widget.section.id, forceRefresh: true);
  }

  Future<void> _launchContentUrl(BuildContext context, String? urlString, String contentType) async {
    final l10n = AppLocalizations.of(context)!;
    if (urlString == null || urlString.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.appTitle.contains("መጂወ") ? "$contentType አልተገኘም" : "$contentType not available.")),
      );
      return;
    }

    final Uri uri = Uri.parse(urlString);
    if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {
      if (mounted) { // Check if widget is still in the tree
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("${l10n.appTitle.contains("መጂወ") ? "$urlString መክፈት አልተቻለም" : "Could not launch"} $urlString")),
        );
      }
    }
  }

  Widget _buildLessonItem(BuildContext context, Lesson lesson) {
    final theme = Theme.of(context);
    IconData lessonIcon = Icons.article_outlined; // Default
    Color iconColor = theme.colorScheme.primary;
    String typeDescription = "Content";

    // Determine icon and color based on lessonType or other properties
    switch (lesson.lessonType) {
      case LessonType.video:
        lessonIcon = Icons.play_circle_outline_rounded;
        iconColor = Colors.red.shade600;
        typeDescription = "Video";
        break;
      case LessonType.document:
        lessonIcon = Icons.description_outlined;
        iconColor = Colors.green.shade700;
        typeDescription = "Document";
        break;
      case LessonType.quiz:
        lessonIcon = Icons.quiz_outlined;
        iconColor = Colors.purple.shade600;
        typeDescription = "Quiz";
        break;
      case LessonType.text:
         lessonIcon = Icons.notes_outlined;
         iconColor = Colors.orange.shade700;
         typeDescription = "Text";
         break;
      default: // LessonType.unknown
        lessonIcon = Icons.extension_outlined;
        iconColor = theme.disabledColor;
        typeDescription = "Content";
    }

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 5, horizontal: 8),
      child: ListTile(
        leading: Icon(lessonIcon, color: iconColor, size: 36),
        title: Text(lesson.title, style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w500)),
        subtitle: lesson.summary != null && lesson.summary!.isNotEmpty
            ? Text(lesson.summary!, maxLines: 2, overflow: TextOverflow.ellipsis, style: theme.textTheme.bodySmall)
            : Text(typeDescription, style: theme.textTheme.bodySmall), // Fallback to type description
        trailing: lesson.duration != null && lesson.duration!.isNotEmpty
            ? Text(lesson.duration!, style: theme.textTheme.bodySmall)
            : const Icon(Icons.arrow_forward_ios, size: 14),
        onTap: () {
          // Determine what to launch based on lesson content
          if (lesson.lessonType == LessonType.video && lesson.videoUrl != null) {
            _launchContentUrl(context, lesson.videoUrl, "Video");
          } else if (lesson.lessonType == LessonType.document && lesson.attachmentUrl != null) {
            _launchContentUrl(context, lesson.attachmentUrl, "Document");
          } else if (lesson.lessonType == LessonType.quiz) {
            // TODO: Navigate to Quiz taking screen
            ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Quiz: ${lesson.title} (Not implemented)")));
          } else if (lesson.lessonType == LessonType.text && lesson.summary != null){ // Or a specific text content field
             // TODO: Navigate to a screen to show full text lesson, or show in a dialog
            showDialog(context: context, builder: (dCtx) => AlertDialog(
                title: Text(lesson.title),
                content: SingleChildScrollView(child: Text(lesson.summary ?? "No text content.")),
                actions: [TextButton(child: const Text("Close"), onPressed: ()=>Navigator.of(dCtx).pop())],
            ));
          }
           else {
            ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("No launchable content for: ${lesson.title}")));
          }
        },
      ),
    );
  }
  
  // Placeholder builders for different content types, adapt as needed
  Widget _buildVideoList(BuildContext context, List<Lesson> lessons) {
    final videoLessons = lessons.where((l) => l.lessonType == LessonType.video).toList();
    if (videoLessons.isEmpty) return Center(child: Text(AppLocalizations.of(context)!.appTitle.contains("መጂወ") ? "ምንም ቪዲዮዎች የሉም።" : "No videos available."));
    return ListView.builder(
      padding: const EdgeInsets.all(8),
      itemCount: videoLessons.length,
      itemBuilder: (ctx, index) => _buildLessonItem(context, videoLessons[index]),
    );
  }

  Widget _buildDocumentList(BuildContext context, List<Lesson> lessons) { // Renamed from PDF
    final docLessons = lessons.where((l) => l.lessonType == LessonType.document).toList();
     if (docLessons.isEmpty) return Center(child: Text(AppLocalizations.of(context)!.appTitle.contains("መጂወ") ? "ምንም ሰነዶች የሉም።" : "No documents available."));
    return ListView.builder(
      padding: const EdgeInsets.all(8),
      itemCount: docLessons.length,
      itemBuilder: (ctx, index) => _buildLessonItem(context, docLessons[index]),
    );
  }
   Widget _buildTextList(BuildContext context, List<Lesson> lessons) {
    final textLessons = lessons.where((l) => l.lessonType == LessonType.text).toList();
     if (textLessons.isEmpty) return Center(child: Text(AppLocalizations.of(context)!.appTitle.contains("መጂወ") ? "ምንም የጽሑፍ ትምህርቶች የሉም።" : "No text lessons available."));
    return ListView.builder(
      padding: const EdgeInsets.all(8),
      itemCount: textLessons.length,
      itemBuilder: (ctx, index) => _buildLessonItem(context, textLessons[index]),
    );
  }


  Widget _buildQuizList(BuildContext context, List<Lesson> lessons) {
    final quizLessons = lessons.where((l) => l.lessonType == LessonType.quiz).toList();
    if (quizLessons.isEmpty) return Center(child: Text(AppLocalizations.of(context)!.appTitle.contains("መጂወ") ? "ምንም ፈተናዎች የሉም።" : "No quizzes available."));
    return ListView.builder(
      padding: const EdgeInsets.all(8),
      itemCount: quizLessons.length,
      itemBuilder: (ctx, index) => _buildLessonItem(context, quizLessons[index]),
    );
  }


  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final lessonProvider = Provider.of<LessonProvider>(context);
    final List<Lesson> lessons = lessonProvider.lessonsForSection(widget.section.id);
    final bool isLoading = lessonProvider.isLoadingForSection(widget.section.id);
    final String? error = lessonProvider.errorForSection(widget.section.id);

    return Scaffold(
      appBar: AppBar(
        title: Text(widget.section.title, overflow: TextOverflow.ellipsis, style: const TextStyle(fontSize: 18)),
        bottom: TabBar(
          controller: _tabController,
          isScrollable: false, // Can set to true if many tabs or long labels
          labelColor: theme.colorScheme.primary,
          unselectedLabelColor: theme.colorScheme.onSurface.withOpacity(0.6),
          indicatorColor: theme.colorScheme.primary,
          tabs: [ // Example tabs, adjust based on your LessonType filtering
            Tab(text: l10n.appTitle.contains("መጂወ") ? "ቪዲዮዎች" : "Videos"),
            Tab(text: l10n.appTitle.contains("መጂወ") ? "ማስታወሻዎች" : "Notes"), // Or "Text" if more generic
            Tab(text: l10n.appTitle.contains("መጂወ") ? "ሰነዶች" : "Documents"), // Or "PDFs"
            Tab(text: l10n.appTitle.contains("መጂወ") ? "ፈተናዎች" : "Quizzes"),
          ],
        ),
      ),
      body: RefreshIndicator(
        onRefresh: _refreshLessons,
        child: Builder(
          builder: (context) {
            if (isLoading && lessons.isEmpty) {
              return const Center(child: CircularProgressIndicator());
            }
            if (error != null && lessons.isEmpty) {
              return Center(
                child: Padding(
                  padding: const EdgeInsets.all(20.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.error_outline, color: theme.colorScheme.error, size: 50),
                      const SizedBox(height: 16),
                      Text(
                         l10n.appTitle.contains("መጂወ") ? "ትምህርቶችን መጫን አልተሳካም።\n$error" : "Failed to load lessons.\n$error",
                        textAlign: TextAlign.center,
                         style: TextStyle(color: theme.colorScheme.onSurface.withOpacity(0.7)),
                      ),
                      const SizedBox(height: 20),
                      ElevatedButton.icon(
                        icon: const Icon(Icons.refresh),
                        label: Text(l10n.refresh),
                        onPressed: _refreshLessons,
                      )
                    ],
                  ),
                ),
              );
            }
            // No lessons check is handled by individual tab builders now.
            // if (lessons.isEmpty && !isLoading) {
            //   return Center(child: Text(l10n.appTitle.contains("መጂወ") ? "ለዚህ ምዕራፍ ምንም ትምህርቶች የሉም።" : "No lessons in this chapter yet."));
            // }

            return TabBarView(
              controller: _tabController,
              children: [
                _buildVideoList(context, lessons),
                _buildTextList(context, lessons),    // Assuming "Notes" tab shows text-based lessons
                _buildDocumentList(context, lessons),// Assuming "Documents" tab shows document-type lessons
                _buildQuizList(context, lessons),
              ],
            );
          },
        ),
      ),
    );
  }
}
// lib/screens/library/library_content_view.dart
import 'package:flutter/material.dart';
// import 'package:provider/provider.dart'; // We'll comment this out for now
import 'package:mgw_tutorial/widgets/library/course_card.dart';
import 'package:mgw_tutorial/screens/library/course_sections_screen.dart';
import 'package:mgw_tutorial/models/api_course.dart'; // Still need the model
import 'package:flutter_gen/gen_l10n/app_localizations.dart';


class LibraryContentView extends StatefulWidget {
  const LibraryContentView({super.key});

  @override
  State<LibraryContentView> createState() => _LibraryContentViewState();
}

class _LibraryContentViewState extends State<LibraryContentView> {

  // Helper function to create mock ApiCourse objects
  ApiCourse _createMockCourse(int id, String title, String shortDesc, String thumbnailLetter) {
    return ApiCourse(
      id: id,
      title: title,
      shortDescription: shortDesc,
      description: "This is a placeholder for course ID $id. Sections and lessons should load if the APIs for sections (course ID $id) and subsequent lessons are working.",
      outcomes: ["Outcome A for $id", "Outcome B for $id"],
      requirements: ["Requirement for $id"],
      price: (id % 2 == 0) ? "0.00" : "50.00", // Example price logic
      status: "published",
      createdAt: DateTime.now().subtract(Duration(days: id + 5)),
      updatedAt: DateTime.now().subtract(Duration(days: id)),
      thumbnail: "https://via.placeholder.com/600x300.png?text=Course+$thumbnailLetter",
      // Ensure all non-nullable fields in ApiCourse constructor are covered
      // categoryId: null, // Make these nullable in model or provide default
      // section: null,
      // language: null,
      // videoUrl: null,
      // discountFlag: null,
      // discountedPrice: null,
      // isTopCourse: null,
      // isVideoCourse: null,
      // isFreeCourse: id % 2 == 0,
      // multiInstructor: null,
      // creator: null,
      // category: null,
    );
  }

  late List<ApiCourse> _hardcodedCourses;

  @override
  void initState() {
    super.initState();
    _hardcodedCourses = [
      _createMockCourse(38, "Course Alpha (ID 38)", "Content for course 38", "A"),
      _createMockCourse(0, "Course Beta (ID 0)", "Content for course 0", "B"), // Assuming ID 0 is valid
      _createMockCourse(40, "Course Gamma (ID 40)", "Content for course 40", "G"),
      _createMockCourse(41, "Course Delta (ID 41)", "Content for course 41", "D"),
    ];

    // ApiCourseProvider related fetching is disabled for now
  }

  // _refreshCourses is also disabled as we are using hardcoded data
  // Future<void> _refreshCourses() async {
  //   ScaffoldMessenger.of(context).showSnackBar(
  //      const SnackBar(content: Text("Refresh disabled (using hardcoded courses)."))
  //   );
  // }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final List<ApiCourse> displayCourses = _hardcodedCourses;

    if (displayCourses.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.school_outlined, size: 80, color: Colors.grey),
            const SizedBox(height: 16),
            Text(
              l10n.appTitle.contains("መጂወ") ? "ምንም ኮርሶች የሉም።" : "No courses available at the moment.",
              style: const TextStyle(fontSize: 17),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    return ListView.builder(
        padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
        itemCount: displayCourses.length,
        itemBuilder: (context, index) {
          final course = displayCourses[index];
          return Padding(
            padding: const EdgeInsets.only(bottom: 12.0),
            child: CourseCard(
              course: course,
              onTap: () {
                Navigator.pushNamed(
                  context,
                  CourseSectionsScreen.routeName,
                  arguments: course,
                );
              },
            ),
          );
        },
    );
  }
}
//lib/screens/library/library_screen.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/screens/library/library_content_view.dart';

class LibraryScreen extends StatefulWidget {
  // final LibraryState initialState; // No longer needed

  const LibraryScreen({
    Key? key,
    // this.initialState = LibraryState.notRegistered, // No longer needed
  }) : super(key: key);

  @override
  State<LibraryScreen> createState() => _LibraryScreenState();
}

class _LibraryScreenState extends State<LibraryScreen> {
  

  @override
  void initState() {
    super.initState();
    
  }

 
  @override
  Widget build(BuildContext context) {
    // Directly return LibraryContentView
    return const Padding(
      padding: EdgeInsets.all(16.0), // Keep padding if desired
      child: LibraryContentView(),
    );
  }
}
//lib/screens/library/not_registered_view.dart
import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
class NotRegisteredView extends StatelessWidget {
  final VoidCallback onRegisterNow;

  const NotRegisteredView({super.key, required this.onRegisterNow});

  @override
  Widget build(BuildContext context) {
    
    final l10n = AppLocalizations.of(context)!;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          
          Icon(Icons.search_off, size: 100, color: Colors.blue[700]),
          const SizedBox(height: 24),
          Text(
             l10n.notRegisteredTitle,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: Colors.grey[800],
            ),
          ),
          const SizedBox(height: 16),
          Text(
            l10n.notRegisteredSubtitle,
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 16, color: Colors.grey[700]),
          ),
          const SizedBox(height: 32),
          ElevatedButton(
            onPressed: onRegisterNow,
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 15),
            ),
            child:  Text(l10n.getRegisteredNowButton),
          ),
        ],
      ),
    );
  }
}
//lib/screens/library/registration_denied_view.dart
import 'package:flutter/material.dart';

class RegistrationDeniedView extends StatelessWidget {
  final VoidCallback onRegisterNow;
  const RegistrationDeniedView({super.key, required this.onRegisterNow});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Icon(Icons.cancel, size: 100, color: Colors.red[700]),
          const SizedBox(height: 24),
          Text(
            'Your request has been denied!',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: Colors.red[700],
            ),
          ),
          const SizedBox(height: 16),
          Text(
            'Your request has been denied because the screenshot you have sent was invalid. Please provide a valid screenshot.',
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 16, color: Colors.grey[700]),
          ),
          const SizedBox(height: 32),
          ElevatedButton(
            onPressed: onRegisterNow,
             style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 15),
            ),
            child: const Text('Get Registered Now'),
          ),
        ],
      ),
    );
  }
}
//lib/screens/library/registration_pending_view.dart
import 'package:flutter/material.dart';

class RegistrationPendingView extends StatelessWidget {
  const RegistrationPendingView({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Icon(Icons.check_circle, size: 100, color: Colors.blue[700]),
          const SizedBox(height: 24),
          Text(
            'Your request is under verification.',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: Colors.grey[800],
            ),
          ),
          const SizedBox(height: 16),
          Text(
            'You will gain access to our extensive library of pdfs, notes and video tutorials once your request is verified.',
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 16, color: Colors.grey[700]),
          ),
        ],
      ),
    );
  }
}
//lib/screens/notifications/notifications_screen.dart
import 'package:flutter/material.dart';

class NotificationsScreen extends StatelessWidget {
  const NotificationsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: const Center(child: Text('you have no notifications yet')),
    );
  }
}
// lib/screens/registration/registration_screen.dart
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/provider/department_provider.dart';
// import 'package:mgw_tutorial/provider/api_course_provider.dart'; // REMOVE if not used elsewhere
import 'package:mgw_tutorial/provider/semester_provider.dart'; // <-- USE THIS
import 'package:mgw_tutorial/provider/order_provider.dart';
import 'package:mgw_tutorial/services/device_info.dart';
import 'package:mgw_tutorial/models/user.dart';
import 'package:mgw_tutorial/models/department.dart';
// import 'package:mgw_tutorial/models/api_course.dart'; // REMOVE if not used elsewhere
import 'package:mgw_tutorial/models/semester.dart'; // <-- USE THIS
import 'package:mgw_tutorial/models/order.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:mgw_tutorial/widgets/phone_form_field.dart';
import 'package:mgw_tutorial/widgets/password_form_field.dart';

class RegistrationScreen extends StatefulWidget {
  const RegistrationScreen({super.key});
  @override
  State<RegistrationScreen> createState() => _RegistrationScreenState();
}

class _RegistrationScreenState extends State<RegistrationScreen> {
  final _formKey = GlobalKey<FormState>();

  final _studentNameController = TextEditingController();
  final _fatherNameController = TextEditingController();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();

  Department? _selectedDepartment;
  String? _selectedInstitution;
  String? _selectedGender;
  String? _selectedYear;
  String? _selectedBankName;
  Semester? _selectedSemester; // Changed type to Semester

  XFile? _pickedXFile;
  final ImagePicker _picker = ImagePicker();
  bool _agreedToTerms = false;
  bool _isPasswordVisible = false;

  final DeviceInfoService _deviceInfoService = DeviceInfoService();
  String _deviceInfoString = 'Fetching device info...';

  bool _hasAttemptedSubmit = false;

  final List<String> _institutions = [
    'Addis Ababa University', 'Bahir Dar University', 'Hawassa University', 'Other',
  ];
  final List<String> _academicYears = [
    '1st Year', '2nd Year', '3rd Year', '4th Year', '5th Year', '6th Year', '7th Year'
  ];
  final List<Map<String, String>> _bankAccounts = [
    {'name': 'CBE', 'accountNumber': '1000 123 4587 4584', 'holder': 'Debebe Workabeb Tessema'},
    {'name': 'Telebirr', 'accountNumber': '09 45 45 78 45', 'holder': 'Debebe Workabeb Tessema'},
  ];

  @override
  void initState() {
    super.initState();
    _getDeviceInfo();
    Future.microtask(() {
      Provider.of<DepartmentProvider>(context, listen: false).fetchDepartments();
      Provider.of<SemesterProvider>(context, listen: false).fetchSemesters(); // Fetch semesters
    });
  }

  @override
  void dispose() {
    _studentNameController.dispose();
    _fatherNameController.dispose();
    _phoneController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _getDeviceInfo() async {
    await WidgetsBinding.instance.endOfFrame;
    if (!mounted) return;

    final deviceData = await _deviceInfoService.getDeviceData();
    String brand = deviceData['brand'] ?? deviceData['name'] ?? 'UnknownBrand';
    String model = deviceData['model'] ?? deviceData['localizedModel'] ?? 'UnknownModel';
    String os = deviceData['systemName'] ?? deviceData['platform'] ?? 'UnknownOS';
    
    String deviceType = "Unknown Device"; 
    if (mounted) { 
        try {
             deviceType = _deviceInfoService.detectDeviceType(context);
        } catch (e) {
            print("Error detecting device type in RegistrationScreen initState: $e.");
        }
    }

    if (mounted) {
      setState(() {
        _deviceInfoString = '$deviceType - $brand $model, $os';
        print("Device Info for Registration: $_deviceInfoString");
      });
    }
  }

  void _togglePasswordVisibility() {
    setState(() { _isPasswordVisible = !_isPasswordVisible; });
  }

  Future<void> _pickScreenshot() async {
    if (!mounted) return;
    final l10n = AppLocalizations.of(context)!;
    try {
      final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery);
      if (pickedFile != null && mounted) {
        setState(() { _pickedXFile = pickedFile; });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.errorPickingImage(e.toString()))));
      }
    }
  }

  Future<void> _submitForm() async {
    final l10n = AppLocalizations.of(context)!;
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final orderProvider = Provider.of<OrderProvider>(context, listen: false);

    if (!mounted) return;

    authProvider.clearError();
    orderProvider.clearError();

    setState(() { _hasAttemptedSubmit = true; });
    if (!_formKey.currentState!.validate()) return;

    if (_selectedDepartment == null) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.pleaseSelectDepartmentError))); return; }
    if (_selectedInstitution == null) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.pleaseSelectInstitutionError))); return; }
    if (_selectedYear == null) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.pleaseSelectYearError))); return; }
    if (_selectedGender == null) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.pleaseSelectGenderError))); return; }
    if (_selectedSemester == null) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.pleaseSelectSemesterError))); return; }
    if (_selectedBankName == null) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please select a bank for payment reference.'))); return; }
    if (_pickedXFile == null) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.pleaseAttachScreenshotError))); return; }
    if (!_agreedToTerms) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.pleaseAgreeToTermsError))); return; }

    String rawPhoneInput = _phoneController.text.trim();
    String? finalPhoneNumberForUser;
    String phoneForOrder;

    if (rawPhoneInput.startsWith('0') && rawPhoneInput.length == 10) {
        finalPhoneNumberForUser = '+251${rawPhoneInput.substring(1)}';
        phoneForOrder = rawPhoneInput;
    } else if (rawPhoneInput.length == 9 && int.tryParse(rawPhoneInput) != null && !rawPhoneInput.startsWith('+')) {
        finalPhoneNumberForUser = '+251$rawPhoneInput';
        phoneForOrder = '0$rawPhoneInput';
    } else if (rawPhoneInput.startsWith('+251') && rawPhoneInput.length == 13) {
        finalPhoneNumberForUser = rawPhoneInput;
        phoneForOrder = '0${rawPhoneInput.substring(4)}';
    } else {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.invalidPhoneNumberFormatError)));
        return;
    }

    final User registrationPayload = User(
      firstName: _studentNameController.text.trim(),
      lastName: _fatherNameController.text.trim(),
      phone: finalPhoneNumberForUser!,
      password: _passwordController.text,
      grade: _selectedYear!,
      category: _selectedDepartment!.name,
      school: _selectedInstitution!,
      gender: _selectedGender!,
      device: _deviceInfoString,
      // serviceType: _selectedSemester!.name, // If you need to send semester info with User
      status: "pending",
      allCourses: false,
      enrolledAll: false,
      region: "Not Specified",
    );

    bool userRegistrationSuccess = await authProvider.registerUserFull(
        registrationData: registrationPayload,
        screenshotFile: _pickedXFile,
    );

    if (!userRegistrationSuccess) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(authProvider.apiError?.message ?? l10n.registrationFailedDefaultMessage),
            backgroundColor: Colors.redAccent,
          ),
        );
      }
      return;
    }

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("${l10n.registrationSuccessMessage} Now submitting your semester selection...")),
      );

      List<OrderSelectionItem> orderSelections = [];
      if (_selectedSemester != null) {
        orderSelections.add(OrderSelectionItem(
          id: _selectedSemester!.id.toString(), // Use Semester's id
          name: _selectedSemester!.name,        // Use Semester's name
        ));
      }

      final Order orderPayloadForFields = Order(
        fullName: '${_studentNameController.text.trim()} ${_fatherNameController.text.trim()}',
        bankName: _selectedBankName,
        phone: phoneForOrder,
        type: "semester_enrollment", // Or a type that makes sense for semester enrollment
        status: "pending",
        selections: orderSelections,
      );

      bool orderCreationSuccess = await orderProvider.createOrder(
        orderData: orderPayloadForFields,
        screenshotFile: _pickedXFile,
      );

      if (mounted) {
        if (orderCreationSuccess) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('User registered and semester selection submitted successfully! Awaiting approval.')),
          );
          if (Navigator.canPop(context)) {
            Navigator.pop(context);
          }
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text("User registered, but semester selection failed: ${orderProvider.error ?? 'Unknown order error.'}"),
              backgroundColor: Colors.orangeAccent,
              duration: const Duration(seconds: 5),
            ),
          );
        }
      }
    }
  }

  Widget _buildPaymentInfoTile(AppLocalizations l10n, String bankName, String accountNumber, String accountHolder) {
    bool isSelected = _selectedBankName == bankName;
    return Card(
      elevation: isSelected ? 4.0 : 1.0,
      shape: RoundedRectangleBorder(
        side: BorderSide(color: isSelected ? Theme.of(context).primaryColor : Colors.grey.shade300, width: isSelected ? 2 : 1),
        borderRadius: BorderRadius.circular(8.0),
      ),
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      child: InkWell(
        onTap: () {
          setState(() {
            _selectedBankName = bankName;
          });
        },
        borderRadius: BorderRadius.circular(8.0),
        child: ListTile(
          leading: Icon(Icons.account_balance, color: isSelected ? Theme.of(context).primaryColor : Colors.grey[600]),
          title: Text(bankName, style: TextStyle(fontWeight: FontWeight.bold, color: isSelected ? Theme.of(context).primaryColor : null)),
          subtitle: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${l10n.bankAccountLabel}: $accountNumber'),
              Text('${l10n.bankHolderNameLabel}: $accountHolder'),
            ],
          ),
          trailing: IconButton(
            icon: const Icon(Icons.copy, size: 20),
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(l10n.copiedToClipboardMessage(accountNumber))));
            },
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.getRegisteredTitle),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          autovalidateMode: _hasAttemptedSubmit ? AutovalidateMode.onUserInteraction : AutovalidateMode.disabled,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              // ... (User detail TextFormFields - studentName, fatherName, phone, password) ...
              TextFormField(controller: _studentNameController, decoration: InputDecoration(labelText: l10n.studentNameLabel), validator: (v) => (v == null || v.trim().isEmpty) ? l10n.studentNameValidationError : null),
              const SizedBox(height: 16),
              TextFormField(controller: _fatherNameController, decoration: InputDecoration(labelText: l10n.fatherNameLabel), validator: (v) => (v == null || v.trim().isEmpty) ? l10n.fatherNameValidationError : null),
              const SizedBox(height: 16),
              PhoneFormField(controller: _phoneController, l10n: l10n),
              const SizedBox(height: 16),
              PasswordFormField(controller: _passwordController, isPasswordVisible: _isPasswordVisible, onToggleVisibility: _togglePasswordVisibility, l10n: l10n),
              const SizedBox(height: 20),

              // ... (Department Dropdown) ...
              Text(l10n.departmentLabel, style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              Consumer<DepartmentProvider>(
                builder: (context, deptProvider, child) {
                   if (deptProvider.isLoading && deptProvider.departments.isEmpty) {
                    return const Center(child: CircularProgressIndicator(strokeWidth: 2.0));
                  }
                  if (deptProvider.error != null && deptProvider.departments.isEmpty) {
                    return Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Failed to load departments. Please check connection.', style: TextStyle(color: Theme.of(context).colorScheme.error)),
                        ElevatedButton.icon(icon: const Icon(Icons.refresh, size: 18), label: const Text('Reload'), onPressed: () => deptProvider.fetchDepartments(), style: ElevatedButton.styleFrom(backgroundColor: Theme.of(context).colorScheme.errorContainer,foregroundColor: Theme.of(context).colorScheme.onErrorContainer, padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8), textStyle: const TextStyle(fontSize: 14))),
                      ],
                    );
                  }
                  if (deptProvider.departments.isEmpty && !deptProvider.isLoading) {
                    return Text('No departments available.', style: TextStyle(color: Colors.grey[700]));
                  }
                  return DropdownButtonFormField<Department>(
                    decoration: InputDecoration(hintText: l10n.selectDepartmentHint, border: const OutlineInputBorder(), filled: true, fillColor: Colors.white, contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0)),
                    value: _selectedDepartment,
                    isExpanded: true,
                    items: deptProvider.departments.map((Department department) => DropdownMenuItem<Department>(value: department, child: Text(department.name))).toList(),
                    onChanged: (Department? newValue) => setState(() => _selectedDepartment = newValue),
                    validator: (value) => value == null ? l10n.pleaseSelectDepartmentError : null,
                  );
                },
              ),
              const SizedBox(height: 20),

              // ... (Institution Dropdown) ...
              Text(l10n.institutionLabel, style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              DropdownButtonFormField<String>(
                decoration: InputDecoration(hintText: l10n.selectInstitutionHint, border: const OutlineInputBorder(), filled: true, fillColor: Colors.white, contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0)),
                value: _selectedInstitution,
                isExpanded: true,
                items: _institutions.map((String institution) => DropdownMenuItem<String>(value: institution, child: Text(institution))).toList(),
                onChanged: (newValue) => setState(() => _selectedInstitution = newValue),
                validator: (value) => value == null ? l10n.institutionValidationError : null,
              ),
              const SizedBox(height: 20),

              // ... (Year Dropdown) ...
              Text(l10n.yearLabel, style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              DropdownButtonFormField<String>(
                decoration: InputDecoration(hintText: l10n.selectYearHint, border: const OutlineInputBorder(), filled: true, fillColor: Colors.white, contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0)),
                value: _selectedYear,
                isExpanded: true,
                items: _academicYears.map((String year) => DropdownMenuItem<String>(value: year, child: Text(year))).toList(),
                onChanged: (String? newValue) => setState(() => _selectedYear = newValue),
                validator: (value) => value == null ? l10n.pleaseSelectYearError : null,
              ),
              const SizedBox(height: 20),


              // ... (Gender Radio Buttons) ...
              Text(l10n.genderLabel, style: Theme.of(context).textTheme.titleMedium),
              Row(children: [
                Expanded(child: RadioListTile<String>(title: Text(l10n.maleGender), value: 'Male', groupValue: _selectedGender, onChanged: (v) => setState(() => _selectedGender = v))),
                Expanded(child: RadioListTile<String>(title: Text(l10n.femaleGender), value: 'Female', groupValue: _selectedGender, onChanged: (v) => setState(() => _selectedGender = v)))
              ]),
              if (_hasAttemptedSubmit && _selectedGender == null)
                 Padding(
                   padding: const EdgeInsets.only(top: 8.0, left: 12.0),
                   child: Text(l10n.pleaseSelectGenderError, style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12)),
                 ),
              const SizedBox(height: 20),


              // --- MODIFIED DROPDOWN: Uses SemesterProvider ---
              Text(l10n.selectSemesterLabel, style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              Consumer<SemesterProvider>( // Use SemesterProvider
                builder: (context, semesterProvider, child) {
                  if (semesterProvider.isLoading && semesterProvider.semesters.isEmpty) {
                    return const Center(child: CircularProgressIndicator(strokeWidth: 2));
                  }
                  if (semesterProvider.error != null && semesterProvider.semesters.isEmpty) {
                    return Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Failed to load semesters. Please check connection.', style: TextStyle(color: Theme.of(context).colorScheme.error)),
                        ElevatedButton.icon(icon: const Icon(Icons.refresh, size: 18), label: const Text('Reload'), onPressed: () => semesterProvider.fetchSemesters(), style: ElevatedButton.styleFrom(backgroundColor: Theme.of(context).colorScheme.errorContainer,foregroundColor: Theme.of(context).colorScheme.onErrorContainer, padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8), textStyle: const TextStyle(fontSize: 14))),
                      ],
                    );
                  }
                  if (semesterProvider.semesters.isEmpty && !semesterProvider.isLoading) {
                    return Text("No semesters available.", style: TextStyle(color: Colors.grey[700]));
                  }

                  if (_selectedSemester != null && !semesterProvider.semesters.any((s) => s.id == _selectedSemester!.id)) {
                      WidgetsBinding.instance.addPostFrameCallback((_) {
                        if(mounted) {
                           setState(() { _selectedSemester = null; });
                        }
                      });
                  }

                  return DropdownButtonFormField<Semester>( // Use Semester type
                    decoration: InputDecoration(
                      hintText: l10n.selectSemesterHint,
                      border: const OutlineInputBorder(),
                      filled: true,
                      fillColor: Colors.white,
                      contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0),
                    ),
                    value: _selectedSemester,
                    isExpanded: true,
                    items: semesterProvider.semesters.map((Semester semester) { // Iterate over Semester objects
                      return DropdownMenuItem<Semester>(
                        value: semester,
                        child: Text("${semester.name} - ${semester.year} (${semester.price} ETB)"), // Display Semester properties
                      );
                    }).toList(),
                    onChanged: (Semester? newValue) {
                      setState(() {
                        _selectedSemester = newValue;
                      });
                    },
                    validator: (value) => value == null ? l10n.pleaseSelectSemesterError : null,
                  );
                },
              ),
              if (_hasAttemptedSubmit && _selectedSemester == null)
                 Padding(
                   padding: const EdgeInsets.only(top: 8.0, left: 12.0),
                   child: Text(l10n.pleaseSelectSemesterError, style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12)),
                 ),
              const SizedBox(height: 20),
              // --- END SEMESTER DROPDOWN ---

              // ... (Payment, Screenshot, Terms, Submit button logic) ...
              Text(l10n.paymentInstruction, style: Theme.of(context).textTheme.bodyMedium),
              const SizedBox(height: 12),
              ..._bankAccounts.map((bank) => _buildPaymentInfoTile(l10n, bank['name']!, bank['accountNumber']!, bank['holder']!)).toList(),
               if (_hasAttemptedSubmit && _selectedBankName == null)
                 Padding(
                   padding: const EdgeInsets.only(top: 8.0, left: 12.0),
                   child: Text("Please select a bank for payment reference.", style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12)),
                 ),
              const SizedBox(height: 20),

              OutlinedButton.icon(
                  icon: const Icon(Icons.attach_file),
                  label: Text(_pickedXFile == null ? l10n.attachScreenshotButton : l10n.screenshotAttachedButton),
                  onPressed: _pickScreenshot,
                  style: OutlinedButton.styleFrom( padding: const EdgeInsets.symmetric(vertical: 12), textStyle: const TextStyle(fontSize: 16), side: BorderSide(color: Theme.of(context).primaryColor))),
              if (_pickedXFile != null)
                Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text('${l10n.fileNamePrefix}: ${_pickedXFile!.name}', style: TextStyle(color: Colors.green[700]), textAlign: TextAlign.center, overflow: TextOverflow.ellipsis)),
              if (_hasAttemptedSubmit && _pickedXFile == null)
                 Padding(
                   padding: const EdgeInsets.only(top: 8.0, left: 12.0),
                   child: Text(l10n.pleaseAttachScreenshotError, style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12)),
                 ),
              const SizedBox(height: 24),

              CheckboxListTile(
                title: RichText(
                    text: TextSpan(
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).textTheme.bodyLarge?.color),
                        children: [
                      TextSpan(text: l10n.termsAndConditionsAgreement),
                      TextSpan(text: l10n.termsAndConditionsLink, style: TextStyle(color: Theme.of(context).primaryColor, decoration: TextDecoration.underline)),
                      TextSpan(text: l10n.termsAndConditionsAnd),
                      TextSpan(text: l10n.privacyPolicyLink, style: TextStyle(color: Theme.of(context).primaryColor, decoration: TextDecoration.underline))
                    ])),
                value: _agreedToTerms,
                onChanged: (bool? value) => setState(() => _agreedToTerms = value ?? false),
                controlAffinity: ListTileControlAffinity.leading,
                contentPadding: EdgeInsets.zero,
              ),
              if (_hasAttemptedSubmit && !_agreedToTerms)
                 Padding(
                   padding: const EdgeInsets.only(top: 8.0, left: 12.0),
                   child: Text(l10n.pleaseAgreeToTermsError, style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12)),
                 ),
              const SizedBox(height: 24),

              Consumer2<AuthProvider, OrderProvider>( // Listen to both for isLoading
                builder: (context, auth, order, child) {
                  return (auth.isLoading || order.isLoading)
                      ? const Center(child: CircularProgressIndicator())
                      : ElevatedButton(onPressed: _submitForm, child: Text(l10n.submitButton));
                },
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }
}
//lib/screens/sidebar
//lib/screens/sidebar/about_us_screen.dart
import 'package:flutter/material.dart';

class AboutUsScreen extends StatelessWidget {
  // Define the routeName for navigation
  static const String routeName = '/about-us';

  const AboutUsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // The AppBar's appearance will be controlled by the AppBarTheme in main.dart
      appBar: AppBar(
        title: const Text('About Us'),
      ),
      body: SingleChildScrollView( // Use SingleChildScrollView if content might overflow
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            Text(
              'Welcome to MGW Tutorial!',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).primaryColorDark, // Or Colors.black
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'MGW Tutorial is dedicated to providing high-quality educational resources to help students excel in their studies. Our platform offers a wide range of tutorials, notes, practice exams, and more, tailored to the curriculum.',
              style: TextStyle(fontSize: 16, height: 1.5),
            ),
            const SizedBox(height: 20),
            Text(
              'Our Mission',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 8),
            const Text(
              'To empower students with the knowledge and tools they need to achieve academic success and unlock their full potential.',
              style: TextStyle(fontSize: 16, height: 1.5),
            ),
            const SizedBox(height: 20),
            Text(
              'Contact Us',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 8),
            const ListTile(
              leading: Icon(Icons.email),
              title: Text('info@mgwtutorial.com'),
              // onTap: () { /* TODO: Launch email client */ },
            ),
            const ListTile(
              leading: Icon(Icons.phone),
              title: Text('+251 9XX XXX XXX'),
              // onTap: () { /* TODO: Launch phone dialer */ },
            ),
            const SizedBox(height: 20),
            Center(
              child: Text(
                '© ${DateTime.now().year} MGW Tutorial. All rights reserved.',
                style: TextStyle(fontSize: 12, color: Colors.grey[600]),
              ),
            )
          ],
        ),
      ),
    );
  }
}
// lib/screens/sidebar/create_post_screen.dart
import 'package:flutter/material.dart';
// import 'package:mgw_tutorial/provider/auth_provider.dart'; // Not needed if DiscussionProvider handles it
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/discussion_provider.dart';

class CreatePostScreen extends StatefulWidget {
  static const routeName = '/create-post';
  const CreatePostScreen({super.key});
  @override
  State<CreatePostScreen> createState() => _CreatePostScreenState();
}

class _CreatePostScreenState extends State<CreatePostScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  // bool _isLoading = false; // This will be handled by DiscussionProvider's state

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  Future<void> _submitPost() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    _formKey.currentState!.save();

    // setState(() { _isLoading = true; }); // Handled by provider

    final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
    // final authProvider = Provider.of<AuthProvider>(context, listen: false); // Not directly passed

    // The createPost method in DiscussionProvider now handles authProvider internally.
    bool success = await discussionProvider.createPost(
      title: _titleController.text.trim(),
      description: _descriptionController.text.trim(),
      // authProvider: authProvider, // REMOVE THIS LINE
    );

    if (mounted) {
      // setState(() { _isLoading = false; }); // Handled by provider
      if (success) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Post created successfully!')),
        );
        Navigator.of(context).pop(true);
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            // Use the correct error getter from DiscussionProvider
            content: Text(discussionProvider.submitPostError ?? 'Failed to create post. Please try again.'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Access the loading state from DiscussionProvider to show CircularProgressIndicator
    final discussionProvider = Provider.of<DiscussionProvider>(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Create New Post'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              TextFormField(
                controller: _titleController,
                decoration: const InputDecoration(
                  labelText: 'Post Title',
                  hintText: 'Enter a clear and concise title',
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter a title.';
                  }
                  if (value.trim().length < 5) {
                    return 'Title must be at least 5 characters long.';
                  }
                  return null;
                },
                textInputAction: TextInputAction.next,
              ),
              const SizedBox(height: 20),
              TextFormField(
                controller: _descriptionController,
                decoration: const InputDecoration(
                  labelText: 'Post Description',
                  hintText: 'Share your thoughts or questions in detail...',
                  alignLabelWithHint: true,
                ),
                maxLines: 8,
                minLines: 5,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter a description.';
                  }
                  if (value.trim().length < 10) {
                    return 'Description must be at least 10 characters long.';
                  }
                  return null;
                },
                keyboardType: TextInputType.multiline,
              ),
              const SizedBox(height: 30),
              discussionProvider.isSubmittingPost // Use loading state from provider
                  ? const Center(child: CircularProgressIndicator())
                  : ElevatedButton(
                      onPressed: _submitPost,
                      child: const Text('Submit Post'),
                    ),
            ],
          ),
        ),
      ),
    );
  }
}
// lib/screens/sidebar/discussion_group_screen.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/models/post.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart'; 
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/discussion_provider.dart';
import 'package:mgw_tutorial/screens/sidebar/post_detail_screen.dart';
import 'package:intl/intl.dart';
import 'create_post_screen.dart';

class DiscussionGroupScreen extends StatefulWidget {
  static const routeName = '/discussion-group';

  const DiscussionGroupScreen({super.key});

  @override
  State<DiscussionGroupScreen> createState() => _DiscussionGroupScreenState();
}

class _DiscussionGroupScreenState extends State<DiscussionGroupScreen> {
  @override
  void initState() {
    super.initState();
    Future.microtask(() {
      final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
      if (discussionProvider.posts.isEmpty) {
        discussionProvider.fetchPosts();
      }
    });
  }

  void _navigateToCreatePostScreen() async {
    final result = await Navigator.of(context).pushNamed(CreatePostScreen.routeName);
    if (result == true && mounted) {
      // List will be updated by provider after successful post creation
    }
  }

   void _navigateToPostDetailScreen(Post post) { // Modified
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => PostDetailScreen(post: post),
      ),
    );
    
  }

  @override
  Widget build(BuildContext context) {
    final discussionProvider = Provider.of<DiscussionProvider>(context);
    final authProvider = Provider.of<AuthProvider>(context, listen: false); // Get AuthProvider here

    return Scaffold(
      appBar: AppBar(
        title: const Text('Discussion Group'), // TODO: Localize
      ),
      body: RefreshIndicator(
        onRefresh: () => discussionProvider.fetchPosts(),
        child: _buildPostBody(discussionProvider, authProvider), // <<< PASS authProvider HERE
      ),
      floatingActionButton: authProvider.currentUser != null ? FloatingActionButton(
        onPressed: _navigateToCreatePostScreen,
        backgroundColor: Theme.of(context).primaryColor,
        child: const Icon(Icons.add, color: Colors.white),
        tooltip: 'Create Post', // TODO: Localize
      ) : null,
    );
  }

  // VVVVV MODIFY METHOD SIGNATURE HERE VVVVV
  Widget _buildPostBody(DiscussionProvider discussionProvider, AuthProvider authProvider) {
  // ^^^^^ PASS authProvider AS ARGUMENT ^^^^^
    if (discussionProvider.isLoadingPosts && discussionProvider.posts.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    if (discussionProvider.postsError != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(discussionProvider.postsError!, style: TextStyle(color: Colors.red[700]), textAlign: TextAlign.center),
              const SizedBox(height: 10),
              ElevatedButton(
                onPressed: () => discussionProvider.fetchPosts(),
                child: const Text('Retry'), // TODO: Localize
              )
            ],
          ),
        ),
      );
    }

    if (!discussionProvider.isLoadingPosts && discussionProvider.posts.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'No discussions yet. Be the first to start one!', // TODO: Localize
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(fontSize: 18),
              ),
              const SizedBox(height: 20),
              // VVVVV ACCESS authProvider PASSED AS ARGUMENT VVVVV
              if (authProvider.currentUser != null)
                ElevatedButton.icon(
                  icon: const Icon(Icons.add_comment_outlined),
                  label: const Text("Start a Discussion"), // TODO: Localize
                  onPressed: _navigateToCreatePostScreen,
                )
            ],
          ),
        )
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(8.0),
      itemCount: discussionProvider.posts.length,
      itemBuilder: (ctx, index) {
        final post = discussionProvider.posts[index];
        return Card(
          elevation: 3,
          margin: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 4.0),
          child: InkWell(
            onTap: () => _navigateToPostDetailScreen(post),
            borderRadius: BorderRadius.circular(12.0),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    post.title,
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(
                          color: Theme.of(context).primaryColorDark,
                          fontWeight: FontWeight.w600
                        ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    post.description,
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Colors.grey[800]),
                    maxLines: 3,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 12),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'By: ${post.author.name}',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                              fontStyle: FontStyle.italic,
                              color: Colors.grey[700],
                            ),
                      ),
                      Text(
                        DateFormat.yMMMd().add_jm().format(post.createdAt.toLocal()),
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                              color: Colors.grey[600],
                            ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}
// lib/screens/sidebar/post_detail_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/models/post.dart';
import 'package:mgw_tutorial/models/comment.dart';
import 'package:mgw_tutorial/models/reply.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/provider/discussion_provider.dart';
import 'package:mgw_tutorial/widgets/discussion/post_content_view.dart';
import 'package:mgw_tutorial/widgets/discussion/comment_item_view.dart';
import 'package:mgw_tutorial/widgets/discussion/comment_input_field.dart';
import 'package:mgw_tutorial/widgets/discussion/edit_input_field.dart';
// import 'package:intl/intl.dart'; // Already imported in PostContentView and CommentItemView if needed there

class PostDetailScreen extends StatefulWidget {
  static const routeName = '/post-detail';
  final Post post;

  const PostDetailScreen({super.key, required this.post});

  @override
  State<PostDetailScreen> createState() => _PostDetailScreenState();
}

class _PostDetailScreenState extends State<PostDetailScreen> {
  // For top-level comment
  final _topLevelCommentController = TextEditingController();
  final _topLevelCommentFormKey = GlobalKey<FormState>();

  // For replying (shared controller and key for one active reply field)
  int? _replyingToCommentId;
  final _replyController = TextEditingController();
  final _replyFormKey = GlobalKey<FormState>();

  // For editing comments or replies
  int? _editingCommentId;
  int? _editingReplyId;
  int? _editingReplyParentCommentId; // Need this to update the correct comment's reply list
  final _editTextController = TextEditingController();
  final _editFormKey = GlobalKey<FormState>();

  // For editing the main post
  final _editPostTitleController = TextEditingController();
  final _editPostDescriptionController = TextEditingController();
  final _editPostFormKey = GlobalKey<FormState>();

  // To store the current post object that might be updated
  late Post _currentPost;


  @override
  void initState() {
    super.initState();
    _currentPost = widget.post; // Initialize with the passed post
    _fetchData();
  }

  Future<void> _fetchData({bool forceRefresh = false}) async {
    if (!mounted) return;
    final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
    
    // Fetch the specific post again if refreshing, to get latest version
    // This assumes PostProvider has a method like fetchPostById(id) or fetchPosts() updates the list
    // For now, we'll rely on fetchPosts updating the list in DiscussionProvider
    if (forceRefresh) {
      await discussionProvider.fetchPosts(); // Refreshes the whole list
      // Find the updated post from the list
      final updatedPostFromList = discussionProvider.posts.firstWhere(
            (p) => p.id == widget.post.id,
            orElse: () => _currentPost); // Fallback to current if somehow not found
      if (mounted) {
        setState(() {
          _currentPost = updatedPostFromList;
        });
      }
    }
    
    await discussionProvider.fetchCommentsForPost(_currentPost.id, forceRefresh: forceRefresh);
    
    if (mounted) {
      final comments = discussionProvider.commentsForPost(_currentPost.id);
      for (var comment in comments) {
        if (forceRefresh || !discussionProvider.allRepliesLoadedForComment(comment.id)) {
           discussionProvider.fetchRepliesForComment(comment.id, forceRefresh: forceRefresh);
        }
      }
    }
  }

  @override
  void dispose() {
    _topLevelCommentController.dispose();
    _replyController.dispose();
    _editTextController.dispose();
    _editPostTitleController.dispose();
    _editPostDescriptionController.dispose();
    super.dispose();
  }

  // --- Post Actions ---
  void _showEditPostDialog() {
    final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
    _editPostTitleController.text = _currentPost.title;
    _editPostDescriptionController.text = _currentPost.description;

    showDialog(
      context: context,
      builder: (ctx) => StatefulBuilder( // Use StatefulBuilder for dialog's own loading state
        builder: (BuildContext context, StateSetter setDialogState) {
          return AlertDialog(
            title: const Text('Edit Post'),
            contentPadding: const EdgeInsets.all(20),
            content: Form(
              key: _editPostFormKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    controller: _editPostTitleController,
                    decoration: const InputDecoration(labelText: 'Title'),
                    validator: (value) => (value == null || value.trim().isEmpty) ? 'Title cannot be empty' : null,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _editPostDescriptionController,
                    decoration: const InputDecoration(labelText: 'Description', alignLabelWithHint: true),
                    maxLines: 5, minLines: 3,
                    validator: (value) => (value == null || value.trim().isEmpty) ? 'Description cannot be empty' : null,
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(ctx).pop()),
              ElevatedButton(
                child: discussionProvider.isUpdatingItem
                    ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation(Colors.white)))
                    : const Text('Save'),
                onPressed: discussionProvider.isUpdatingItem ? null : () async {
                  if (_editPostFormKey.currentState!.validate()) {
                    final success = await discussionProvider.updatePost(
                      postId: _currentPost.id,
                      title: _editPostTitleController.text.trim(),
                      description: _editPostDescriptionController.text.trim(),
                    );
                    if (!mounted) return;
                    Navigator.of(ctx).pop();
                    if (success) {
                      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Post updated!')));
                      // Refresh data to show updated post details on this screen
                      await _fetchData(forceRefresh: true);
                    } else {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(discussionProvider.updateItemError ?? 'Failed to update post.'), backgroundColor: Colors.red),
                      );
                    }
                  }
                },
              ),
            ],
          );
        }
      ),
    );
  }

  Future<void> _handleDeletePost() async {
    final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
    final bool? confirmDelete = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete Post'),
        content: const Text('Are you sure you want to delete this post and all its comments? This action cannot be undone.'),
        actions: <Widget>[
          TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(ctx).pop(false)),
          TextButton(
            child: const Text('Delete', style: TextStyle(color: Colors.red)),
            onPressed: () => Navigator.of(ctx).pop(true),
          ),
        ],
      ),
    );

    if (confirmDelete == true) {
      final success = await discussionProvider.deletePost(_currentPost.id);
      if (mounted) {
        if (success) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Post deleted successfully!')));
          Navigator.of(context).pop(); 
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(discussionProvider.deleteItemError ?? 'Failed to delete post.'), backgroundColor: Colors.red),
          );
        }
      }
    }
  }

  // --- Top-Level Comment Actions ---
  Future<void> _submitTopLevelComment() async {
    if (!_topLevelCommentFormKey.currentState!.validate()) return;
    final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
    final success = await discussionProvider.createTopLevelComment(
      postId: _currentPost.id,
      commentText: _topLevelCommentController.text.trim(),
    );
    if (mounted) {
      if (success) {
        _topLevelCommentController.clear();
        FocusScope.of(context).unfocus(); // Hide keyboard
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Comment posted!')));
      } else {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(discussionProvider.submitCommentError ?? 'Failed to post comment.'), backgroundColor: Colors.red));
      }
    }
  }

  // --- Reply Actions ---
  void _handleToggleReplyField(int commentId) {
    _cancelEdit(); // Ensure any comment/reply edit mode is cancelled
    setState(() {
      if (_replyingToCommentId == commentId) {
        _replyingToCommentId = null;
      } else {
        _replyingToCommentId = commentId;
        _replyController.clear(); // Clear previous text
        // Consider requesting focus for _replyController here if desired
      }
    });
  }

  Future<void> _submitReply(int parentCommentId) async {
    if (!_replyFormKey.currentState!.validate()) return;
    final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
    final success = await discussionProvider.createReply(
      parentCommentId: parentCommentId,
      content: _replyController.text.trim(),
    );
    if (mounted) {
      if (success) {
        _replyController.clear();
        setState(() { _replyingToCommentId = null; });
        FocusScope.of(context).unfocus(); // Hide keyboard
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Reply posted!')));
      } else {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(discussionProvider.submitReplyError ?? 'Failed to post reply.'), backgroundColor: Colors.red));
      }
    }
  }

  // --- Edit Comment/Reply Actions ---
  void _startEditComment(Comment comment) {
    setState(() {
      _editingCommentId = comment.id;
      _editingReplyId = null;
      _editingReplyParentCommentId = null;
      _editTextController.text = comment.comment;
      _replyingToCommentId = null; // Close reply input
    });
  }

  void _startEditReply(Reply reply, int parentCommentId) {
    setState(() {
      _editingReplyId = reply.id;
      _editingReplyParentCommentId = parentCommentId;
      _editingCommentId = null;
      _editTextController.text = reply.content;
      _replyingToCommentId = null; // Close reply input
    });
  }

  void _cancelEdit() {
    setState(() {
      _editingCommentId = null;
      _editingReplyId = null;
      _editingReplyParentCommentId = null;
      _editTextController.clear();
    });
  }

  Future<void> _submitEdit() async {
    if (!_editFormKey.currentState!.validate()) return;
    final dp = Provider.of<DiscussionProvider>(context, listen: false);
    bool success = false;

    if (_editingCommentId != null) {
      success = await dp.updateComment(
        commentId: _editingCommentId!,
        postId: _currentPost.id,
        newCommentText: _editTextController.text.trim(),
      );
    } else if (_editingReplyId != null && _editingReplyParentCommentId != null) {
      success = await dp.updateReply(
        parentCommentId: _editingReplyParentCommentId!,
        replyId: _editingReplyId!,
        newContent: _editTextController.text.trim(),
      );
    }

    if (mounted) {
      if (success) {
        _cancelEdit();
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Update successful!')));
      } else {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(dp.updateItemError ?? 'Update failed.'), backgroundColor: Colors.red));
      }
    }
  }

  // --- Delete Comment/Reply Actions ---
  Future<void> _handleDeleteComment(int commentId) async {
    await _confirmDeleteDialog("comment", commentId);
  }

  Future<void> _handleDeleteReply(int replyId, int parentCommentId) async {
    await _confirmDeleteDialog("reply", replyId, parentId: parentCommentId);
  }

  Future<void> _confirmDeleteDialog(String type, int id, {int? parentId}) async {
    final bool? confirmDelete = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text('Delete ${type[0].toUpperCase()}${type.substring(1)}'), // TODO: Localize
        content: Text('Are you sure you want to delete this $type? This action cannot be undone.'), // TODO: Localize
        actions: <Widget>[
          TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(ctx).pop(false)), // TODO: Localize
          TextButton(
            child: const Text('Delete', style: TextStyle(color: Colors.red)), // TODO: Localize
            onPressed: () => Navigator.of(ctx).pop(true),
          ),
        ],
      ),
    );

    if (confirmDelete == true) {
      final dp = Provider.of<DiscussionProvider>(context, listen: false);
      bool success = false;
      if (type == "comment") {
        success = await dp.deleteComment(commentId: id, postId: _currentPost.id);
      } else if (type == "reply" && parentId != null) {
        success = await dp.deleteReply(parentCommentId: parentId, replyId: id);
      }
      if (mounted) {
        if (success) {
          ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('${type[0].toUpperCase()}${type.substring(1)} deleted successfully!'))); // TODO: Localize
        } else {
          ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(dp.deleteItemError ?? 'Failed to delete $type.'), backgroundColor: Colors.red)); // TODO: Localize
        }
      }
    }
  }


  @override
  Widget build(BuildContext context) {
    final discussionProvider = Provider.of<DiscussionProvider>(context); // Listen for general updates
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final comments = discussionProvider.commentsForPost(_currentPost.id);

    return Scaffold(
      appBar: AppBar(
        title: Text(_currentPost.title, overflow: TextOverflow.ellipsis, style: const TextStyle(fontSize: 18)),
      ),
      body: Column(
        children: [
          Expanded(
            child: RefreshIndicator(
              onRefresh: () => _fetchData(forceRefresh: true),
              child: ListView(
                padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 0), // No bottom padding for ListView
                children: [
                  PostContentView(
                    post: _currentPost, // Use the state variable _currentPost
                    authProvider: authProvider,
                    onEditPost: _showEditPostDialog,
                    onDeletePost: _handleDeletePost,
                  ),
                  Padding(
                    padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
                    child: Text(
                      'Comments (${comments.length})', // TODO: Localize
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
                    ),
                  ),
                  if (discussionProvider.isLoadingCommentsForPost(_currentPost.id) && comments.isEmpty)
                    const Center(child: Padding(padding: EdgeInsets.all(16.0),child: CircularProgressIndicator())),
                  if (discussionProvider.commentErrorForPost(_currentPost.id) != null && comments.isEmpty)
                    Center(child: Padding(padding: const EdgeInsets.all(16.0), child: Text(discussionProvider.commentErrorForPost(_currentPost.id)! ))),
                  if (comments.isEmpty && !discussionProvider.isLoadingCommentsForPost(_currentPost.id) && discussionProvider.commentErrorForPost(_currentPost.id) == null)
                    const Center(child: Padding(padding: EdgeInsets.symmetric(vertical: 20.0), child: Text('No comments yet. Be the first!'))), // TODO: Localize
                  
                  ...comments.map((comment) => CommentItemView(
                        key: ValueKey(comment.id), // Add key for better list item management
                        comment: comment,
                        discussionProvider: discussionProvider,
                        authProvider: authProvider,
                        onToggleReplyField: _handleToggleReplyField,
                        isReplyFieldOpen: _replyingToCommentId == comment.id && _editingCommentId == null && _editingReplyId == null,
                        onSubmitReply: _submitReply,
                        replyController: _replyController,
                        replyFormKey: _replyFormKey,
                        onStartEditComment: _startEditComment,
                        onDeleteComment: _handleDeleteComment,
                        onStartEditReply: _startEditReply,
                        onDeleteReply: _handleDeleteReply,
                      )).toList(),
                  
                  // Edit Input Field (shown at the bottom of comments if active)
                  if (_editingCommentId != null || _editingReplyId != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 16.0),
                      child: EditInputField(
                          controller: _editTextController,
                          formKey: _editFormKey,
                          isEditingComment: _editingCommentId != null,
                          discussionProvider: discussionProvider,
                          onCancel: _cancelEdit,
                          onSubmit: _submitEdit,
                      ),
                    ),
                  const SizedBox(height: 70), // Space for the bottom input field if visible
                ],
              ),
            ),
          ),
          // Top-level comment input field
          // Only show if not editing another comment/reply
          if (authProvider.currentUser != null && _editingCommentId == null && _editingReplyId == null)
            CommentInputField(
              controller: _topLevelCommentController,
              formKey: _topLevelCommentFormKey,
              discussionProvider: discussionProvider,
              onSubmit: _submitTopLevelComment,
            ),
        ],
      ),
    );
  }
}
// lib/screens/sidebar/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/locale_provider.dart';
import 'package:mgw_tutorial/provider/theme_provider.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart'; // For logout
import 'package:mgw_tutorial/screens/auth/login_screen.dart'; // For logout navigation
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class SettingsScreen extends StatefulWidget {
  static const String routeName = '/settings';
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  // Supported languages - should match main.dart and AppLocalizations
  // Store language codes, display names will be from l10n
  final List<String> _supportedLanguageCodes = ['en', 'am', 'or'];
  bool _receivePushNotifications = true; // Keep this as a local UI state for now

  String _getLanguageDisplayName(BuildContext context, String langCode) {
    final l10n = AppLocalizations.of(context)!;
    switch (langCode) {
      case 'en':
        return l10n.english;
      case 'am':
        return l10n.amharic;
      case 'or':
        return l10n.afaanOromo;
      default:
        return langCode.toUpperCase();
    }
  }

  @override
  Widget build(BuildContext context) {
    final localeProvider = Provider.of<LocaleProvider>(context);
    final themeProvider = Provider.of<ThemeProvider>(context);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final l10n = AppLocalizations.of(context)!;

    // Determine current language code for the dropdown
    String currentLanguageCode = localeProvider.locale?.languageCode ?? 'en';
    if (!_supportedLanguageCodes.contains(currentLanguageCode)) {
      currentLanguageCode = _supportedLanguageCodes.first; // Default if current is not supported
    }
    
    bool isCurrentlyDarkMode = themeProvider.themeMode == ThemeMode.dark;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.settings),
      ),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        children: <Widget>[
          SwitchListTile(
            title: Text(l10n.appTitle.contains("መጂወ") ? "ጨለማ ገፅታ" : "Dark Mode"), // Simple conditional localization for demo
            subtitle: Text(l10n.appTitle.contains("መጂወ") ? "የጨለማ ገፅታን አንቃ ወይም አሰናክል" : "Enable or disable dark theme"),
            value: isCurrentlyDarkMode,
            onChanged: (bool value) {
              themeProvider.toggleTheme(value);
            },
            secondary: Icon(isCurrentlyDarkMode ? Icons.dark_mode : Icons.light_mode),
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.language),
            title: Text(l10n.changeLanguage),
            trailing: DropdownButton<String>(
              value: currentLanguageCode,
              underline: const SizedBox(),
              icon: const Icon(Icons.arrow_drop_down),
              onChanged: (String? newLanguageCode) {
                if (newLanguageCode != null) {
                  localeProvider.setLocale(Locale(newLanguageCode));
                }
              },
              items: _supportedLanguageCodes
                  .map<DropdownMenuItem<String>>((String langCode) {
                return DropdownMenuItem<String>(
                  value: langCode,
                  child: Text(_getLanguageDisplayName(context, langCode)),
                );
              }).toList(),
            ),
          ),
          const Divider(),
          SwitchListTile(
            title: Text(l10n.notifications), // Using existing notifications string
            subtitle: Text(l10n.appTitle.contains("መጂወ") ? "ጠቃሚ ዝመናዎችን ተቀበል" : "Receive important updates"),
            value: _receivePushNotifications,
            onChanged: (bool value) {
              setState(() {
                _receivePushNotifications = value;
              });
              // TODO: Update notification preferences with backend/Firebase
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Push Notifications ${value ? "Enabled" : "Disabled"}')),
              );
            },
            secondary: const Icon(Icons.notifications_active_outlined),
          ),
          // Email Updates SwitchListTile is removed
          const Divider(),
          ListTile(
            leading: const Icon(Icons.policy_outlined),
            title: Text(l10n.privacyPolicyLink), // Using existing privacy policy string
            onTap: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('View Privacy Policy (Not Implemented)')),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.description_outlined),
            title: Text(l10n.termsAndConditionsLink), // Using existing terms string
            onTap: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('View Terms of Service (Not Implemented)')),
              );
            },
          ),
          const Divider(),
          if (authProvider.currentUser != null)
            ListTile(
              leading: Icon(Icons.logout, color: Theme.of(context).colorScheme.error),
              title: Text(l10n.logout, style: TextStyle(color: Theme.of(context).colorScheme.error)),
              onTap: () async {
                await authProvider.logout();
                if (mounted) {
                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute(builder: (context) => const LoginScreen()),
                    (Route<dynamic> route) => false,
                  );
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text(l10n.logoutSuccess)),
                  );
                }
              },
            ),
        ],
      ),
    );
  }
}
// lib/screens/sidebar/testimonials_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/testimonial_provider.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/models/testimonial.dart'; // Correct model
import 'package:intl/intl.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
// import 'package:image_picker/image_picker.dart'; // Uncomment if implementing image picking
// import 'dart:io'; // Uncomment if using File for image preview

// Dialog for creating a new testimonial
class CreateTestimonialDialog extends StatefulWidget {
  final int userId;
  const CreateTestimonialDialog({super.key, required this.userId});

  @override
  State<CreateTestimonialDialog> createState() => _CreateTestimonialDialogState();
}

class _CreateTestimonialDialogState extends State<CreateTestimonialDialog> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  // XFile? _pickedImageFile; // Uncomment for image picking

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  // Future<void> _pickImage() async { // Uncomment for image picking
  //   final ImagePicker picker = ImagePicker();
  //   try {
  //     final XFile? image = await picker.pickImage(source: ImageSource.gallery);
  //     if (image != null) {
  //       setState(() {
  //         _pickedImageFile = image;
  //       });
  //     }
  //   } catch (e) {
  //     if (mounted) {
  //       ScaffoldMessenger.of(context).showSnackBar(
  //         SnackBar(content: Text('Error picking image: $e')),
  //       );
  //     }
  //   }
  // }

  Future<void> _submitTestimonial() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    final testimonialProvider = Provider.of<TestimonialProvider>(context, listen: false);
    
    bool success = await testimonialProvider.createTestimonial(
      title: _titleController.text.trim(),
      description: _descriptionController.text.trim(),
      userId: widget.userId,
      // imagePaths: _pickedImageFile != null ? [_pickedImageFile!.path] : [], // Example
    );

    if (mounted) {
      Navigator.of(context).pop(success);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final testimonialProvider = Provider.of<TestimonialProvider>(context);

    return AlertDialog(
      title: Text(l10n.appTitle.contains("መጂወ") ? "ምስክርነትዎን ያጋሩ" : "Share Your Testimonial"),
      contentPadding: const EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 0),
      content: Form(
        key: _formKey,
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              TextFormField(
                controller: _titleController,
                decoration: InputDecoration(labelText: l10n.appTitle.contains("መጂወ") ? "ርዕስ" : "Title"),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) return l10n.appTitle.contains("መጂወ") ? "እባክዎ ርዕስ ያስገቡ" : "Please enter a title";
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _descriptionController,
                decoration: InputDecoration(
                  labelText: l10n.appTitle.contains("መጂወ") ? "የእርስዎ ተሞክሮ" : "Your Experience",
                  alignLabelWithHint: true,
                ),
                maxLines: 4,
                minLines: 2,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) return l10n.appTitle.contains("መጂወ") ? "እባክዎ ተሞክሮዎን ያስገቡ" : "Please describe your experience";
                  return null;
                },
              ),
            ],
          ),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: Text(l10n.appTitle.contains("መጂወ") ? "ሰርዝ" : "Cancel"),
          onPressed: testimonialProvider.isLoading ? null : () => Navigator.of(context).pop(false),
        ),
        ElevatedButton(
          onPressed: testimonialProvider.isLoading ? null : _submitTestimonial,
          child: testimonialProvider.isLoading
              ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation(Colors.white)))
              : Text(l10n.appTitle.contains("መጂወ") ? "አስገባ" : "Submit"),
        ),
      ],
    );
  }
}

class TestimonialsScreen extends StatefulWidget {
  static const routeName = '/testimonials';
  const TestimonialsScreen({super.key});

  @override
  State<TestimonialsScreen> createState() => _TestimonialsScreenState();
}

class _TestimonialsScreenState extends State<TestimonialsScreen> {
  String _currentStatusFilter = "approved";

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _fetchData(statusFilter: _currentStatusFilter);
    });
  }

  Future<void> _fetchData({bool forceRefresh = false, String? statusFilter}) async {
    if (mounted) {
      Provider.of<TestimonialProvider>(context, listen: false)
          .fetchTestimonials(forceRefresh: forceRefresh, statusFilter: statusFilter);
    }
  }

  void _showCreateTestimonialDialog() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final l10n = AppLocalizations.of(context)!;

    if (authProvider.currentUser == null) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(content: Text(l10n.pleaseLoginOrRegister)),
        );
      }
      return;
    }

    final success = await showDialog<bool>(
      context: context,
      builder: (_) => CreateTestimonialDialog(userId: authProvider.currentUser!.id!),
    );

    if (success == true && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.appTitle.contains("መጂወ") ? "ምስክርነት ገብቷል! ከማረጋገጫ በኋላ ይታያል።" : "Testimonial submitted! It will appear after approval.")),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final testimonialProvider = Provider.of<TestimonialProvider>(context);
    final List<Testimonial> testimonials = testimonialProvider.testimonials;
    final bool isLoading = testimonialProvider.isLoading;
    final String? error = testimonialProvider.error;
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.testimonials),
      ),
      body: RefreshIndicator(
        onRefresh: () => _fetchData(statusFilter: _currentStatusFilter, forceRefresh: true),
        child: Builder(
          builder: (BuildContext scaffoldContext) {
            if (isLoading && testimonials.isEmpty) {
              return const Center(child: CircularProgressIndicator());
            }

            if (error != null && testimonials.isEmpty) {
              return Center( /* ... Error UI ... */ );
            }

            if (testimonials.isEmpty && !isLoading) {
              return Center( /* ... Empty State UI ... */ );
            }

            // ==================================================================
            // THIS IS THE CORRECTED itemBuilder SECTION
            // ==================================================================
            return ListView.separated(
              padding: const EdgeInsets.all(16.0),
              itemCount: testimonials.length,
              itemBuilder: (ctx, index) {
                final testimonial = testimonials[index];
                // CORRECTLY use fields from the updated Testimonial model
                final String authorName = testimonial.author.name.isNotEmpty ? testimonial.author.name : "Anonymous";
                final String testimonialTitle = testimonial.title;
                final String testimonialDescription = testimonial.description;
                final String? displayImageUrl = testimonial.firstFullImageUrl; 

                return Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row( // Author info row
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: [
                            CircleAvatar(
                              radius: 22,
                              backgroundColor: theme.colorScheme.primaryContainer,
                              child: Text(
                                authorName.isNotEmpty ? authorName[0].toUpperCase() : "A",
                                style: TextStyle(fontSize: 18, color: theme.colorScheme.onPrimaryContainer, fontWeight: FontWeight.w500),
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                authorName,
                                style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),

                        if (displayImageUrl != null) // Main testimonial image
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 8.0),
                            child: ClipRRect(
                              borderRadius: BorderRadius.circular(8.0),
                              child: Image.network(
                                displayImageUrl,
                                height: 180,
                                width: double.infinity,
                                fit: BoxFit.cover,
                                errorBuilder: (context, error, stackTrace) => Container(
                                  height: 180,
                                  color: theme.colorScheme.surfaceVariant,
                                  child: Center(child: Icon(Icons.image_not_supported_outlined, color: theme.colorScheme.onSurfaceVariant, size: 40)),
                                ),
                              ),
                            ),
                          ),

                        Text( // Testimonial Title
                          testimonialTitle, // Use the correct field
                          style: theme.textTheme.titleLarge,
                        ),
                        const SizedBox(height: 8),

                        Text( // Testimonial Description
                          '"${testimonialDescription}"', // Use the correct field
                          style: theme.textTheme.bodyMedium?.copyWith(
                                fontStyle: FontStyle.italic,
                                color: theme.colorScheme.onSurface.withOpacity(0.85),
                                height: 1.45
                              ),
                        ),
                        const SizedBox(height: 12),

                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: [
                            if (testimonial.status != 'approved' && testimonial.status.isNotEmpty && testimonial.status != 'unknown')
                                Chip(
                                  label: Text(testimonial.status, style: TextStyle(fontSize: 10, color: theme.chipTheme.labelStyle?.color ?? theme.colorScheme.onSecondary)),
                                  backgroundColor: theme.chipTheme.backgroundColor?.withOpacity(0.7) ?? theme.colorScheme.secondary.withOpacity(0.7),
                                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 0),
                                  materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                  visualDensity: VisualDensity.compact,
                                )
                            else
                              const SizedBox(),
                            
                            Text(
                              DateFormat.yMMMd().add_jm().format(testimonial.createdAt.toLocal()),
                              style: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6), fontSize: 10),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                );
              },
              separatorBuilder: (context, index) => const SizedBox(height: 12),
            );
          }
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _showCreateTestimonialDialog,
        icon: const Icon(Icons.add_comment_outlined),
        label: Text(l10n.appTitle.contains("መጂወ") ? "ምስክርነት አክል" : "Add Testimonial"),
      ),
    );
  }
}
//lib/screens
//lib/screens/main_screen.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/screens/account/account_screen.dart';
import 'package:mgw_tutorial/screens/home/home_screen.dart';
import 'package:mgw_tutorial/screens/library/library_screen.dart';
import 'package:mgw_tutorial/screens/notifications/notifications_screen.dart';
import 'package:mgw_tutorial/widgets/app_drawer.dart'; // Import the AppDrawer

import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class MainScreen extends StatefulWidget {
  const MainScreen({super.key});

  @override
  State<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> {
  int _selectedIndex = 0;
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();

  static const List<Widget> _widgetOptions = <Widget>[
    HomeScreen(),
    LibraryScreen(),
    NotificationsScreen(),
    AccountScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    
    final List<String> _appBarTitles = <String>[
      l10n.appTitle,
      l10n.library,
      l10n.notifications,
      l10n.account,
    ];
    final List<String> bottomNavLabels = <String>[
      l10n.home,
      l10n.library,
      l10n.notifications,
      l10n.account,
    ];
    return Scaffold(
      key: _scaffoldKey,
      appBar: AppBar(
        title: Text(_appBarTitles[_selectedIndex]),
        leading: IconButton(
          icon: const Icon(Icons.menu),
          onPressed: () {
            _scaffoldKey.currentState?.openDrawer();
          },
        ),
      ),
      drawer: const AppDrawer(),
      body: Center(
        child: _widgetOptions.elementAt(_selectedIndex),
      ),
      bottomNavigationBar: BottomNavigationBar(
        items:  <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: const Icon(Icons.home_outlined),
            activeIcon: const Icon(Icons.home),
            label: bottomNavLabels[0],
          ),
          BottomNavigationBarItem(
            icon: const Icon(Icons.library_books_outlined),
            activeIcon: const Icon(Icons.library_books),
            label: bottomNavLabels[1],
          ),
          BottomNavigationBarItem(
            icon: const Icon(Icons.notifications_none_outlined),
            activeIcon: const Icon(Icons.notifications),
            label: bottomNavLabels[2],
          ),
          BottomNavigationBarItem(
            icon: const Icon(Icons.account_circle_outlined),
            activeIcon: const Icon(Icons.account_circle),
            label: bottomNavLabels[3],
          ),
        ],
        currentIndex: _selectedIndex,
        // selectedItemColor, unselectedItemColor, backgroundColor, type, showUnselectedLabels
        // are now primarily controlled by BottomNavigationBarTheme in main.dart
        onTap: _onItemTapped,
      ),
    );
  }
}



---------------------------------
//lib/services
// lib/services/device_info.dart
import 'dart:async';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart'; // For BuildContext in detectDeviceType
import 'package:flutter/services.dart';

class DeviceInfoService {
  static final DeviceInfoPlugin deviceInfoPlugin = DeviceInfoPlugin();

  Future<Map<String, dynamic>> getDeviceData() async {
    Map<String, dynamic> deviceData = {};

    try {
      if (kIsWeb) {
        deviceData = _readWebBrowserInfo(await deviceInfoPlugin.webBrowserInfo);
      } else {
        deviceData = switch (defaultTargetPlatform) {
          TargetPlatform.android =>
            _readAndroidBuildData(await deviceInfoPlugin.androidInfo),
          TargetPlatform.iOS =>
            _readIosDeviceInfo(await deviceInfoPlugin.iosInfo), // Corrected here
          TargetPlatform.windows =>
            _readWindowsDeviceInfo(await deviceInfoPlugin.windowsInfo),
          TargetPlatform.macOS =>
            _readMacOsDeviceInfo(await deviceInfoPlugin.macOsInfo),
          // Added Linux for completeness, though you might not target it
          TargetPlatform.linux =>
            _readLinuxDeviceInfo(await deviceInfoPlugin.linuxInfo),
          _ => <String, dynamic>{'Error:': 'Platform not supported'},
        };
      }
    } on PlatformException {
      deviceData = <String, dynamic>{'Error:': 'Failed to get platform version.'};
    }

    return deviceData;
  }

  String detectDeviceType(BuildContext context) {
    // This method might be better placed outside if it only needs MediaQuery,
    // or ensure context is always available when called.
    if (defaultTargetPlatform == TargetPlatform.android || defaultTargetPlatform == TargetPlatform.iOS) {
      final double screenWidth = MediaQuery.of(context).size.width;
      if (screenWidth > 600) { // Arbitrary breakpoint for tablets
        return 'Tablet';
      } else {
        return 'Mobile';
      }
    } else if (kIsWeb) {
      return 'Web Browser';
    }
     else {
      return 'Computer'; // For Windows, macOS, Linux desktop
    }
  }

  Map<String, dynamic> _readAndroidBuildData(AndroidDeviceInfo build) {
    return <String, dynamic>{
      'board': build.board,
      'brand': build.brand,
      'device': build.device,
      'fingerprint': build.fingerprint,
      'hardware': build.hardware,
      'host': build.host,
      'id': build.id,
      'manufacturer': build.manufacturer,
      'model': build.model,
      'product': build.product,
      'isPhysicalDevice': build.isPhysicalDevice,
      'version.sdkInt': build.version.sdkInt, // Example of accessing nested version info
    };
  }

  Map<String, dynamic> _readIosDeviceInfo(IosDeviceInfo data) {
    return <String, dynamic>{
      'name': data.name,
      'systemName': data.systemName,
      'systemVersion': data.systemVersion,
      'model': data.model, // e.g., "iPhone", "iPad"
      'localizedModel': data.localizedModel, // e.g., "iPhone 13 Pro"
      'identifierForVendor': data.identifierForVendor,
      'isPhysicalDevice': data.isPhysicalDevice,
      'utsname.sysname:': data.utsname.sysname, // More detailed system info
      'utsname.nodename:': data.utsname.nodename,
      'utsname.release:': data.utsname.release,
      'utsname.version:': data.utsname.version,
      'utsname.machine:': data.utsname.machine, // e.g., "iPhone13,2"
    };
  }

  Map<String, dynamic> _readWebBrowserInfo(WebBrowserInfo data) {
    return <String, dynamic>{
      'browserName': data.browserName.name, // Using .name for enum
      'appCodeName': data.appCodeName,
      'appName': data.appName,
      'appVersion': data.appVersion,
      'deviceMemory': data.deviceMemory, // May be null
      'language': data.language,
      'languages': data.languages, // List of languages
      'platform': data.platform,
      'userAgent': data.userAgent, // Useful for more detailed browser info
      'vendor': data.vendor,
      'hardwareConcurrency': data.hardwareConcurrency, // May be null
    };
  }

  Map<String, dynamic> _readMacOsDeviceInfo(MacOsDeviceInfo data) {
    return <String, dynamic>{
      'computerName': data.computerName,
      'hostName': data.hostName,
      'arch': data.arch,
      'model': data.model,
      'kernelVersion': data.kernelVersion,
      'osRelease': data.osRelease,
      'systemGUID': data.systemGUID, // May be null
    };
  }

  Map<String, dynamic> _readWindowsDeviceInfo(WindowsDeviceInfo data) {
    return <String, dynamic>{
      'numberOfCores': data.numberOfCores,
      'computerName': data.computerName,
      'systemMemoryInMegabytes': data.systemMemoryInMegabytes,
      'userName': data.userName, // Added this from your previous code
      'deviceId': data.deviceId,
      'productId': data.productId,
    };
  }

  // Added for Linux
  Map<String, dynamic> _readLinuxDeviceInfo(LinuxDeviceInfo data) {
    return <String, dynamic>{
      'name': data.name,
      'version': data.version,
      'id': data.id,
      'idLike': data.idLike,
      'versionCodename': data.versionCodename,
      'versionId': data.versionId,
      'prettyName': data.prettyName,
      'buildId': data.buildId,
      'variant': data.variant,
      'variantId': data.variantId,
      'machineId': data.machineId,
    };
  }
}


-----------------------------
//lib/widgets

//lib/auth
// lib/widgets/auth/auth_card_wrapper.dart
import 'package:flutter/material.dart';

class AuthCardWrapper extends StatelessWidget {
  final Widget child;

  const AuthCardWrapper({
    super.key,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 4.0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16.0),
      ),
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: child,
      ),
    );
  }
}
// lib/widgets/auth/auth_form_title.dart
import 'package:flutter/material.dart';

class AuthFormTitle extends StatelessWidget {
  final String title;

  const AuthFormTitle({super.key, required this.title});

  @override
  Widget build(BuildContext context) {
    return Text(
      title,
      style: TextStyle(
        fontSize: 24,
        fontWeight: FontWeight.bold,
        color: Colors.blue[800],
      ),
    );
  }
}
// lib/widgets/auth/auth_navigation_link.dart
import 'package:flutter/material.dart';

class AuthNavigationLink extends StatelessWidget {
  final String leadingText;
  final String linkText;
  final VoidCallback onLinkPressed;

  const AuthNavigationLink({
    super.key,
    required this.leadingText,
    required this.linkText,
    required this.onLinkPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: <Widget>[
        Text(
          leadingText,
          style: TextStyle(color: Colors.grey[700]),
        ),
        TextButton(
          onPressed: onLinkPressed,
          child: Text(
            linkText,
            style: TextStyle(
              color: Colors.blue[700],
              fontWeight: FontWeight.bold,
            ),
          ),
          style: TextButton.styleFrom(
              padding: EdgeInsets.zero,
              minimumSize: const Size(50, 30),
              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              alignment: Alignment.centerLeft),
        ),
      ],
    );
  }
}
// lib/widgets/auth/auth_screen_header.dart
import 'package:flutter/material.dart';

class AuthScreenHeader extends StatelessWidget {
  final String title;
  final String subtitle;

  const AuthScreenHeader({
    super.key,
    required this.title,
    required this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(
          title,
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 32,
            fontWeight: FontWeight.bold,
            color: Colors.blue[800],
          ),
        ),
        const SizedBox(height: 8),
        Text(
          subtitle,
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 16,
            color: Colors.grey[700],
          ),
        ),
      ],
    );
  }
}

//lib/widgets/discussion
// lib/widgets/discussion/comment_input_field.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/provider/discussion_provider.dart';

class CommentInputField extends StatelessWidget {
  final TextEditingController controller;
  final GlobalKey<FormState> formKey;
  final DiscussionProvider discussionProvider;
  final VoidCallback onSubmit;

  const CommentInputField({
    super.key,
    required this.controller,
    required this.formKey,
    required this.discussionProvider,
    required this.onSubmit,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.3),
            spreadRadius: 1,
            blurRadius: 3,
            offset: const Offset(0, -1),
          )
        ],
      ),
      child: Form(
        key: formKey,
        child: Row(
          children: <Widget>[
            Expanded(
              child: TextFormField(
                controller: controller,
                decoration: InputDecoration(
                  hintText: 'Write a comment...',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(25.0),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: Theme.of(context).scaffoldBackgroundColor,
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
                ),
                validator: (v) => (v == null || v.trim().isEmpty) ? 'Comment cannot be empty.' : null,
                textInputAction: TextInputAction.send,
                onFieldSubmitted: (_) => onSubmit(),
              ),
            ),
            const SizedBox(width: 8),
            discussionProvider.isSubmittingComment
                ? const SizedBox(
                    width: 40,
                    height: 40,
                    child: Padding(
                      padding: EdgeInsets.all(8.0),
                      child: CircularProgressIndicator(strokeWidth: 2.5),
                    ),
                  )
                : IconButton(
                    icon: Icon(Icons.send, color: Theme.of(context).primaryColor),
                    onPressed: onSubmit,
                    tooltip: 'Post Comment',
                  ),
          ],
        ),
      ),
    );
  }
}
// lib/widgets/discussion/comment_item_view.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:mgw_tutorial/models/comment.dart';
import 'package:mgw_tutorial/models/reply.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/provider/discussion_provider.dart';

class CommentItemView extends StatefulWidget {
  final Comment comment;
  final DiscussionProvider discussionProvider;
  final AuthProvider authProvider;
  final Function(int commentId) onToggleReplyField;
  final bool isReplyFieldOpen; // True if reply field for THIS comment is open
  final Function(int commentId) onSubmitReply;
  final TextEditingController replyController;
  final GlobalKey<FormState> replyFormKey;
  final Function(Comment comment) onStartEditComment;
  final Function(int commentId) onDeleteComment;
  final Function(Reply reply, int parentCommentId) onStartEditReply;
  final Function(int replyId, int parentCommentId) onDeleteReply;

  const CommentItemView({
    super.key,
    required this.comment,
    required this.discussionProvider,
    required this.authProvider,
    required this.onToggleReplyField,
    required this.isReplyFieldOpen,
    required this.onSubmitReply,
    required this.replyController,
    required this.replyFormKey,
    required this.onStartEditComment,
    required this.onDeleteComment,
    required this.onStartEditReply,
    required this.onDeleteReply,
  });

  @override
  State<CommentItemView> createState() => _CommentItemViewState();
}

class _CommentItemViewState extends State<CommentItemView> {
  void _showCommentActionMenu(BuildContext context, Comment comment) {
    showModalBottomSheet(
      context: context,
      builder: (ctx) {
        return Wrap(
          children: <Widget>[
            ListTile(
              leading: const Icon(Icons.edit_outlined),
              title: const Text('Edit Comment'), // TODO: Localize
              onTap: () {
                Navigator.pop(ctx);
                widget.onStartEditComment(comment);
              },
            ),
            ListTile(
              leading: const Icon(Icons.delete_outline, color: Colors.red),
              title: const Text('Delete Comment', style: TextStyle(color: Colors.red)), // TODO: Localize
              onTap: () {
                Navigator.pop(ctx);
                widget.onDeleteComment(comment.id);
              },
            ),
          ],
        );
      },
    );
  }

  void _showReplyActionMenu(BuildContext context, Reply reply, int parentCommentId) {
    showModalBottomSheet(
      context: context,
      builder: (ctx) {
        return Wrap(
          children: <Widget>[
            ListTile(
              leading: const Icon(Icons.edit_outlined),
              title: const Text('Edit Reply'), // TODO: Localize
              onTap: () {
                Navigator.pop(ctx);
                widget.onStartEditReply(reply, parentCommentId);
              },
            ),
            ListTile(
              leading: const Icon(Icons.delete_outline, color: Colors.red),
              title: const Text('Delete Reply', style: TextStyle(color: Colors.red)), // TODO: Localize
              onTap: () {
                Navigator.pop(ctx);
                widget.onDeleteReply(reply.id, parentCommentId);
              },
            ),
          ],
        );
      },
    );
  }


  @override
  Widget build(BuildContext context) {
    final List<Reply> replies = widget.discussionProvider.repliesForComment(widget.comment.id);
    final bool isLoadingReplies = widget.discussionProvider.isLoadingRepliesForComment(widget.comment.id);
    final String? replyError = widget.discussionProvider.replyErrorForComment(widget.comment.id);
    bool isCommentAuthor = widget.authProvider.currentUser?.id == widget.comment.userId;

    return Card(
      elevation: 1.5,
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ListTile(
            title: Text(widget.comment.author.name, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 15)),
            subtitle: Padding(
              padding: const EdgeInsets.only(top: 4.0),
              child: Text(widget.comment.comment, style: const TextStyle(fontSize: 14.5)),
            ),
            trailing: isCommentAuthor
              ? IconButton(
                  icon: Icon(Icons.more_vert, size: 20, color: Colors.grey[600]),
                  onPressed: () => _showCommentActionMenu(context, widget.comment),
                )
              : Text(
                  DateFormat.yMd().add_jm().format(widget.comment.createdAt.toLocal()),
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(fontSize: 10, color: Colors.grey[600]),
                ),
          ),
          Padding(
            // REMOVE 'const' from EdgeInsets.only if using widget properties
            padding: EdgeInsets.only( // <<< MODIFIED HERE: removed 'const'
                left: 16.0,
                bottom: widget.isReplyFieldOpen ? 0 : 8.0, // This makes it non-constant
                right: 8.0,
                top:0
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.start,
              children: [
                if (widget.authProvider.currentUser != null)
                  TextButton(
                    style: TextButton.styleFrom(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        minimumSize: Size.zero,
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap
                    ),
                    onPressed: () => widget.onToggleReplyField(widget.comment.id),
                    child: Text(widget.isReplyFieldOpen ? 'Cancel' : 'Reply', style: TextStyle(fontSize: 13, color: Theme.of(context).primaryColor)), // TODO: Localize
                  ),
              ],
            ),
          ),
          if (widget.isReplyFieldOpen) _buildReplyInputField(),

          if (isLoadingReplies && replies.isEmpty)
            const Padding(padding: EdgeInsets.symmetric(horizontal: 20.0, vertical: 8.0), child: Center(child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)))),
          if (replyError != null && replies.isEmpty && !isLoadingReplies)
              Padding(padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 8.0), child: Text(replyError, style: TextStyle(color: Colors.red.shade700, fontSize: 12))),
          if (replies.isNotEmpty)
            Padding(
              padding: const EdgeInsets.fromLTRB(20.0, 0, 16.0, 8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: replies.map((reply) => _buildReplyItem(context, reply)).toList(),
              ),
            ),
          if (!isLoadingReplies && !widget.discussionProvider.allRepliesLoadedForComment(widget.comment.id) && widget.comment.replyCount > replies.length)
            Padding(
              padding: const EdgeInsets.only(left: 20, bottom: 8),
              child: TextButton(
                onPressed: () => widget.discussionProvider.fetchRepliesForComment(widget.comment.id, forceRefresh: true),
                child: Text('View all ${widget.comment.replyCount} replies...', style: TextStyle(fontSize: 13, color: Colors.blueGrey[700])), // TODO: Localize
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildReplyInputField() {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16.0, 4.0, 16.0, 12.0),
      child: Form(
        key: widget.replyFormKey,
        child: Row(
          children: <Widget>[
            Expanded(
              child: TextFormField(
                controller: widget.replyController,
                autofocus: true,
                decoration: InputDecoration(
                    hintText: 'Write a reply...',
                    isDense: true,
                    contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 10.0),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(20.0), borderSide: BorderSide(color: Colors.grey[400]!))
                ),
                validator: (v) => (v == null || v.trim().isEmpty) ? 'Reply cannot be empty.' : null,
                textInputAction: TextInputAction.send,
                onFieldSubmitted: (_) => widget.onSubmitReply(widget.comment.id),
              ),
            ),
            const SizedBox(width: 8),
            widget.discussionProvider.isSubmittingReply
                ? const SizedBox(width: 24, height: 24, child: Padding(padding: EdgeInsets.all(2.0), child: CircularProgressIndicator(strokeWidth: 2)))
                : IconButton(icon: Icon(Icons.send, color: Theme.of(context).primaryColor, size: 24), onPressed: () => widget.onSubmitReply(widget.comment.id), padding: EdgeInsets.zero, constraints: const BoxConstraints()),
          ],
        ),
      ),
    );
  }

  Widget _buildReplyItem(BuildContext context, Reply reply) {
    bool isReplyAuthor = widget.authProvider.currentUser?.id == reply.userId;
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
      decoration: BoxDecoration(
        color: Colors.grey[100],
        borderRadius: BorderRadius.circular(8)
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(reply.author.name, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 13, color: Colors.black87)),
              if (isReplyAuthor)
                SizedBox(
                  height: 24, width: 24,
                  child: IconButton(
                    padding: EdgeInsets.zero,
                    icon: Icon(Icons.more_vert, size: 16, color: Colors.grey[600]),
                    onPressed: () => _showReplyActionMenu(context, reply, widget.comment.id),
                  ),
                )
              else
                Text(
                  DateFormat.yMd().add_jm().format(reply.createdAt.toLocal()),
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(fontSize: 9, color: Colors.grey[500]),
                ),
            ],
          ),
          const SizedBox(height: 3),
          Text(reply.content, style: const TextStyle(fontSize: 13.5, color: Colors.black87)),
        ],
      ),
    );
  }
}
// lib/widgets/discussion/edit_input_field.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/provider/discussion_provider.dart';

class EditInputField extends StatelessWidget {
  final TextEditingController controller;
  final GlobalKey<FormState> formKey;
  final bool isEditingComment; // To adjust hint text
  final DiscussionProvider discussionProvider;
  final VoidCallback onCancel;
  final VoidCallback onSubmit;

  const EditInputField({
    super.key,
    required this.controller,
    required this.formKey,
    required this.isEditingComment,
    required this.discussionProvider,
    required this.onCancel,
    required this.onSubmit,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      child: Form(
        key: formKey,
        child: Column(
          children: [
            TextFormField(
              controller: controller,
              decoration: InputDecoration(
                hintText: 'Edit your ${isEditingComment ? "comment" : "reply"}...',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12.0)),
                filled: true,
                fillColor: Theme.of(context).scaffoldBackgroundColor,
              ),
              maxLines: 3,
              minLines: 1,
              validator: (v) => (v == null || v.trim().isEmpty) ? 'Cannot be empty' : null,
            ),
            const SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(onPressed: onCancel, child: const Text("Cancel")),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: discussionProvider.isUpdatingItem ? null : onSubmit,
                  child: discussionProvider.isUpdatingItem
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        )
                      : const Text("Save Changes"),
                ),
              ],
            )
          ],
        ),
      ),
    );
  }
}
// lib/widgets/discussion/post_content_view.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:mgw_tutorial/models/post.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';

class PostContentView extends StatelessWidget {
  final Post post;
  final AuthProvider authProvider;
  final VoidCallback? onEditPost;
  final VoidCallback? onDeletePost;

  const PostContentView({
    super.key,
    required this.post,
    required this.authProvider,
    this.onEditPost,
    this.onDeletePost,
  });

  @override
  Widget build(BuildContext context) {
    bool isAuthor = authProvider.currentUser?.id == post.userId;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: Text(
                post.title,
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
            ),
            if (isAuthor)
              PopupMenuButton<String>(
                icon: Icon(Icons.more_vert, color: Colors.grey[700]),
                onSelected: (value) {
                  if (value == 'edit' && onEditPost != null) {
                    onEditPost!();
                  } else if (value == 'delete' && onDeletePost != null) {
                    onDeletePost!();
                  }
                },
                itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
                  if (onEditPost != null)
                    const PopupMenuItem<String>(
                      value: 'edit',
                      child: ListTile(leading: Icon(Icons.edit_outlined), title: Text('Edit Post')), // TODO: Localize
                    ),
                  if (onDeletePost != null)
                    const PopupMenuItem<String>(
                      value: 'delete',
                      child: ListTile(leading: Icon(Icons.delete_outline, color: Colors.red), title: Text('Delete Post', style: TextStyle(color: Colors.red))), // TODO: Localize
                    ),
                ],
              ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text('By: ${post.author.name}', style: Theme.of(context).textTheme.bodySmall?.copyWith(color: Colors.grey[700])),
            Text(
              DateFormat.yMMMd().add_jm().format(post.createdAt.toLocal()),
              style: Theme.of(context).textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
          ],
        ),
        const Divider(height: 24, thickness: 0.5),
        Text(
          post.description,
          style: Theme.of(context).textTheme.bodyLarge?.copyWith(height: 1.5, color: Colors.black87),
        ),
        const Divider(height: 32, thickness: 1),
      ],
    );
  }
}
//lib/widgets/hime
//lib/widgets/home/notes_card.dart
import 'package:flutter/material.dart';

class NotesCard extends StatelessWidget {
  final String title;
  final String description;
  final String imageUrl;
  final VoidCallback? onTap;

  const NotesCard({
    super.key,
    required this.title,
    required this.description,
    required this.imageUrl,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      child: InkWell(
        onTap: onTap ?? () { /* ... */ },
        borderRadius: BorderRadius.circular(12.0),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                // Use a textTheme style that we've configured for dark mode titles
                style: theme.textTheme.titleLarge, // Or titleMedium
              ),
              const SizedBox(height: 12),
              ClipRRect(
                borderRadius: BorderRadius.circular(8.0),
                child: Image.network(
                  imageUrl,
                  height: 150,
                  width: double.infinity,
                  fit: BoxFit.cover,
                   errorBuilder: (context, error, stackTrace) => Container(
                    height: 150,
                    color: theme.colorScheme.surfaceVariant,
                    child: Center(child: Icon(Icons.broken_image, color: theme.colorScheme.onSurfaceVariant, size: 50)),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                description,
                style: TextStyle(color: theme.colorScheme.onSurface.withOpacity(0.75), fontSize: 15),
              ),
              const SizedBox(height: 8),
            ],
          ),
        ),
      ),
    );
  }
}
//lib/widgets/home/semesters_card.dart
import 'package:flutter/material.dart';

class SemestersCard extends StatelessWidget {
  final String title;
  final String imageUrl;
  final List<String> subjectsLeft;
  final List<String> subjectsRight;
  final String price;
  final VoidCallback? onTap;

  const SemestersCard({
    super.key,
    required this.title,
    required this.imageUrl,
    required this.subjectsLeft,
    required this.subjectsRight,
    required this.price,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      child: InkWell(
        onTap: onTap ?? () { /* ... */ },
        borderRadius: BorderRadius.circular(12.0),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                // Use a textTheme style that we've configured for dark mode titles
                style: theme.textTheme.titleLarge, // Or titleMedium
              ),
              const SizedBox(height: 12),
              ClipRRect(
                borderRadius: BorderRadius.circular(8.0),
                child: Image.network(
                  imageUrl,
                  height: 150,
                  width: double.infinity,
                  fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) => Container(
                    height: 150,
                    color: theme.colorScheme.surfaceVariant,
                    child: Center(child: Icon(Icons.broken_image, color: theme.colorScheme.onSurfaceVariant, size: 50)),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: subjectsLeft
                          .map((subject) => Padding(
                                padding: const EdgeInsets.only(bottom: 4.0),
                                child: Text('• $subject', style: TextStyle(color: theme.colorScheme.onSurface.withOpacity(0.75))),
                              ))
                          .toList(),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: subjectsRight
                          .map((subject) => Padding(
                                padding: const EdgeInsets.only(bottom: 4.0),
                                child: Text('• $subject', style: TextStyle(color: theme.colorScheme.onSurface.withOpacity(0.75))),
                              ))
                          .toList(),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Align(
                alignment: Alignment.centerRight,
                child: Chip(
                  label: Text('$price ETB', style: theme.chipTheme.labelStyle),
                  backgroundColor: theme.chipTheme.backgroundColor,
                  padding: theme.chipTheme.padding,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
//lib/widgets/library
// lib/widgets/library/course_card.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/models/api_course.dart';

class CourseCard extends StatelessWidget {
  final ApiCourse course;
  final VoidCallback onTap;

  const CourseCard({
    super.key,
    required this.course,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    String? imageUrl = course.fullThumbnailUrl;

    return Card(
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            AspectRatio(
              aspectRatio: 16 / 9,
              child: ClipRRect(
                 borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12.0),
                  topRight: Radius.circular(12.0),
                ),
                child: imageUrl != null && imageUrl.isNotEmpty
                    ? Image.network(
                        imageUrl,
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) => Container(
                              color: theme.colorScheme.surfaceVariant,
                              child: Icon(Icons.school_outlined, size: 50, color: theme.colorScheme.onSurfaceVariant),
                            ),
                      )
                    : Container(
                        color: theme.colorScheme.surfaceVariant,
                        child: Icon(Icons.school_outlined, size: 50, color: theme.colorScheme.onSurfaceVariant),
                      ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(12.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: <Widget>[
                  Text(
                    course.title,
                    // Use a textTheme style that is white in dark mode
                    style: theme.textTheme.titleMedium, // Ensure this textTheme style is white in darkTheme
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  if (course.shortDescription != null && course.shortDescription!.isNotEmpty)
                    Text(
                      course.shortDescription!,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.7),
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  const SizedBox(height: 8),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'Price: ${course.discountedPrice ?? course.price} ETB',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                          color: theme.colorScheme.primary, // This will be lightBlue[300] in dark mode
                        ),
                      ),
                    ],
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
// lib/screens/library/course_sections_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/models/api_course.dart';
import 'package:mgw_tutorial/models/section_model.dart'; // Import Section model
import 'package:mgw_tutorial/provider/section_provider.dart'; // Import SectionProvider
import 'package:mgw_tutorial/screens/library/chapter_detail_screen.dart'; // This will be renamed to LessonListScreen

class CourseSectionsScreen extends StatefulWidget {
  static const routeName = '/course-sections';
  final ApiCourse course;

  const CourseSectionsScreen({super.key, required this.course});

  @override
  State<CourseSectionsScreen> createState() => _CourseSectionsScreenState();
}

class _CourseSectionsScreenState extends State<CourseSectionsScreen> {
  @override
  void initState() {
    super.initState();
    _fetchCourseSectionsData();
  }

  Future<void> _fetchCourseSectionsData({bool forceRefresh = false}) async {
    // Use Future.microtask if calling from initState directly, otherwise it's fine
    // if context is already available (e.g. from a button press)
    // For initState, it's safer to ensure the first build completes.
    Future.microtask(() {
      Provider.of<SectionProvider>(context, listen: false)
          .fetchSectionsForCourse(widget.course.id, forceRefresh: forceRefresh);
    });
  }

  @override
  Widget build(BuildContext context) {
    // Listen to SectionProvider for changes specific to this course's sections
    final sectionProvider = Provider.of<SectionProvider>(context);
    final List<Section> sections = sectionProvider.sectionsForCourse(widget.course.id);
    final bool isLoading = sectionProvider.isLoadingForCourse(widget.course.id);
    final String? error = sectionProvider.errorForCourse(widget.course.id);

    return Scaffold(
      appBar: AppBar(
        title: Text(widget.course.title),
      ),
      body: RefreshIndicator(
        onRefresh: () => _fetchCourseSectionsData(forceRefresh: true),
        child: Builder( // Use Builder to ensure context for ScaffoldMessenger is correct if needed
          builder: (context) {
            if (isLoading && sections.isEmpty) {
              return const Center(child: CircularProgressIndicator());
            }

            if (error != null && sections.isEmpty) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Text(
                        'Failed to load sections for this course. Please try again.', // TODO: Localize
                        textAlign: TextAlign.center,
                        style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 16),
                      ),
                    ),
                    // Text(error, style: TextStyle(fontSize: 12, color: Colors.grey)), // Optional: show detailed error
                    const SizedBox(height: 10),
                    ElevatedButton.icon(
                      icon: const Icon(Icons.refresh),
                      label: const Text('Retry Sections'), // TODO: Localize
                      onPressed: () => _fetchCourseSectionsData(forceRefresh: true),
                    ),
                  ],
                ),
              );
            }

            if (sections.isEmpty && !isLoading) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.library_books_outlined, size: 70, color: Colors.grey),
                    const SizedBox(height: 16),
                    Text(
                      'No chapters/sections available for "${widget.course.title}" yet.', // TODO: Localize
                       textAlign: TextAlign.center,
                       style: const TextStyle(fontSize: 16),
                    ),
                  ],
                )
              );
            }

            return ListView.builder(
              padding: const EdgeInsets.all(8.0),
              itemCount: sections.length,
              itemBuilder: (ctx, index) {
                final section = sections[index];
                return Card(
                  margin: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 8.0),
                  elevation: 2.5,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                  child: ListTile(
                    contentPadding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
                    leading: CircleAvatar(
                      backgroundColor: Theme.of(context).primaryColor.withOpacity(0.1),
                      foregroundColor: Theme.of(context).primaryColor,
                      child: Text('${section.order ?? index + 1}'), // Use section.order if available
                    ),
                    title: Text(
                      section.title,
                      style: const TextStyle(fontWeight: FontWeight.w500, fontSize: 16.5),
                    ),
                    // You could add a subtitle here if sections have descriptions or lesson counts
                    // subtitle: Text('${section.lessonCount ?? 0} lessons'),
                    trailing: const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
                    onTap: () {
                      // Navigate to LessonListScreen (currently ChapterDetailScreen)
                      // Pass the actual Section object
                      Navigator.pushNamed(
                        context,
                        ChapterDetailScreen.routeName, // Will be renamed to LessonListScreen.routeName
                        arguments: {
                          // 'subjectTitle': section.title, // Pass section title or course title
                          // For ChapterDetailScreen, it expects 'subjectTitle' and 'chapter' map
                          'subjectTitle': widget.course.title, // Course title as main subject
                          'chapter': { // This is now representing the *Section*
                            'id': section.id.toString(), // Ensure ID is string if ChapterDetailScreen expects it
                            'title': section.title,
                            // Mock data for ChapterDetailScreen's existing structure
                            // This will be replaced when LessonListScreen is implemented
                            'videos': [],
                            'notes': 'Content for ${section.title} will be loaded here.',
                            'pdfs': [],
                            'exams': [],
                          },
                        },
                      );
                      print('Tapped on section: ${section.title} (ID: ${section.id}) for course ${widget.course.id}');
                    },
                  ),
                );
              },
            );
          }
        ),
      ),
    );
  }
}
//lib/widgets/library/subject_card.dart(not used)
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/screens/library/subject_chapters_screen.dart';


class SubjectCard extends StatelessWidget {
  final String title;
  final String imageUrl; // Or IconData
  final VoidCallback onTap;

  const SubjectCard({
    super.key,
    required this.title,
    required this.imageUrl,
    required this.onTap,
  });


  @override
  Widget build(BuildContext context) {
    return Card(
      clipBehavior: Clip.antiAlias, // Ensures the InkWell ripple stays within bounds
      child: InkWell(
        onTap: onTap,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Expanded(
              child: Image.network(
                imageUrl,
                fit: BoxFit.cover,
                errorBuilder: (context, error, stackTrace) =>
                    const Center(child: Icon(Icons.broken_image, size: 50)),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(12.0),
              child: Text(
                title,
                textAlign: TextAlign.center,
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
//lib/widgets/
// lib/widgets/app_drawer.dart
import 'package:flutter/material.dart';
import 'package:mgw_tutorial/screens/auth/login_screen.dart';
import 'package:provider/provider.dart';
import 'package:mgw_tutorial/provider/locale_provider.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/provider/theme_provider.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:share_plus/share_plus.dart';

// Import screen routes for navigation
import 'package:mgw_tutorial/screens/sidebar/about_us_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/settings_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/discussion_group_screen.dart';
import 'package:mgw_tutorial/screens/registration/registration_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/testimonials_screen.dart';

// Import Providers to call their fetch methods
import 'package:mgw_tutorial/provider/semester_provider.dart';
import 'package:mgw_tutorial/provider/api_course_provider.dart';
import 'package:mgw_tutorial/provider/testimonial_provider.dart';
import 'package:mgw_tutorial/provider/discussion_provider.dart';


class AppDrawer extends StatelessWidget {
  const AppDrawer({super.key});

  final String _telegramChannelUrl = "https://t.me/YourTelegramChannelNameOrLink";
  final String _appShareLink = "https://play.google.com/store/apps/details?id=your.app.id";
  final String _appShareMessage = "Check out MGW Tutorial, a great app for learning! ";
  final String _contactEmail = "support@mgwtutorial.com";
  final String _contactPhoneNumber = "+251900000000";


  Future<void> _launchUrl(BuildContext context, String urlString, {bool isMail = false, bool isTel = false}) async {
    Uri uri;
    if (isMail) {
      uri = Uri(scheme: 'mailto', path: urlString, queryParameters: {'subject': 'App Support Query'});
    } else if (isTel) {
      uri = Uri(scheme: 'tel', path: urlString);
    } else {
      uri = Uri.parse(urlString);
    }

    if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Could not launch $urlString')),
        );
      }
    }
  }

  Future<void> _shareApp(BuildContext context) async {
    Navigator.of(context).pop();
    final box = context.findRenderObject() as RenderBox?;
    await Share.share(
      _appShareMessage + _appShareLink,
      subject: 'MGW Tutorial App',
      sharePositionOrigin: box!.localToGlobal(Offset.zero) & box.size,
    );
  }

  void _showContactOptions(BuildContext context) {
    Navigator.of(context).pop();
    final l10n = AppLocalizations.of(context)!;

    showModalBottomSheet(
      context: context,
      builder: (BuildContext bCtx) {
        return SafeArea(
          child: Wrap(
            children: <Widget>[
              ListTile(
                leading: const Icon(Icons.email_outlined),
                title: Text(l10n.appTitle.contains("መጂወ") ? "በኢሜል ያግኙን" : "Contact via Email"),
                subtitle: Text(_contactEmail),
                onTap: () {
                  Navigator.of(bCtx).pop();
                  _launchUrl(context, _contactEmail, isMail: true);
                },
              ),
              if (_contactPhoneNumber.isNotEmpty)
                ListTile(
                  leading: const Icon(Icons.phone_outlined),
                  title: Text(l10n.appTitle.contains("መጂወ") ? "በስልክ ይደውሉ" : "Call Us"),
                  subtitle: Text(_contactPhoneNumber),
                  onTap: () {
                    Navigator.of(bCtx).pop();
                    _launchUrl(context, _contactPhoneNumber, isTel: true);
                  },
                ),
              ListTile(
                leading: const Icon(Icons.web_outlined),
                title: Text(l10n.appTitle.contains("መጂወ") ? "የእኛን ድረ-ገጽ ይጎብኙ" : "Visit our Website"),
                onTap: () {
                   Navigator.of(bCtx).pop();
                   _launchUrl(context, "https://www.zsecreteducation.com");
                },
              ),
            ],
          ),
        );
      },
    );
  }

  Future<void> _handleRefresh(BuildContext context) async {
    Navigator.of(context).pop();
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Refreshing data...'), duration: Duration(seconds: 2)),
    );
    final semesterProvider = Provider.of<SemesterProvider>(context, listen: false);
    final apiCourseProvider = Provider.of<ApiCourseProvider>(context, listen: false);
    final testimonialProvider = Provider.of<TestimonialProvider>(context, listen: false);
    final discussionProvider = Provider.of<DiscussionProvider>(context, listen: false);
    try {
      await semesterProvider.fetchSemesters(forceRefresh: true); // Added forceRefresh assumption
      await apiCourseProvider.fetchCourses(); // Assuming it refreshes or add forceRefresh
      await testimonialProvider.fetchTestimonials(forceRefresh: true);
      await discussionProvider.fetchPosts();
      if (context.mounted) {
        ScaffoldMessenger.of(context).removeCurrentSnackBar();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Data refreshed!'), duration: Duration(seconds: 2)),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).removeCurrentSnackBar();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error refreshing data: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    }
  }

  void _navigateTo(BuildContext context, String routeName) {
    Navigator.of(context).pop();
    Navigator.of(context).pushNamed(routeName);
  }

  // ==================================================================
  // ADD THIS METHOD BACK
  // ==================================================================
  void _showNotImplemented(BuildContext context, String featureName) {
    Navigator.of(context).pop(); // Close the drawer
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('$featureName: Not Implemented Yet')),
    );
  }
  // ==================================================================

  void _handleLogout(BuildContext context, AuthProvider authProvider) async {
    Navigator.of(context).pop();
    await authProvider.logout();
    if (context.mounted) {
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const LoginScreen()),
        (Route<dynamic> route) => false,
      );
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLocalizations.of(context)!.logoutSuccess)),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final localeProvider = Provider.of<LocaleProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context);
    final themeProvider = Provider.of<ThemeProvider>(context);
    final l10n = AppLocalizations.of(context)!;

    bool isDarkMode = themeProvider.themeMode == ThemeMode.dark;
    String userName = l10n.guestUser;
    String userDetail = l10n.pleaseLoginOrRegister;
    String? userImageUrl;
    Color headerTextColor = isDarkMode ? Colors.white : Colors.white;
    Color headerPrimaryColor = Theme.of(context).primaryColor;
    if (isDarkMode) {
        headerPrimaryColor = Theme.of(context).colorScheme.primaryContainer.withOpacity(0.6);
    }
    if (authProvider.currentUser != null) {
      userName = ('${authProvider.currentUser!.firstName} ${authProvider.currentUser!.lastName}').trim();
      if (userName.isEmpty) userName = authProvider.currentUser!.phone;
      userDetail = authProvider.currentUser!.phone;
    }
    Color? itemTextColor = Theme.of(context).listTileTheme.textColor;
    Color? itemIconColor = Theme.of(context).listTileTheme.iconColor;

    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: <Widget>[
          UserAccountsDrawerHeader(
             accountName: Text(userName, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: headerTextColor)),
             accountEmail: Text(userDetail, style: TextStyle(color: headerTextColor.withOpacity(0.85))),
             currentAccountPicture: CircleAvatar(
               backgroundImage: userImageUrl != null && userImageUrl.isNotEmpty ? NetworkImage(userImageUrl) : null,
               backgroundColor: Colors.white,
               child: (userImageUrl == null || userImageUrl.isEmpty) ? Icon(Icons.person, size: 40, color: headerPrimaryColor) : null,
             ),
             decoration: BoxDecoration(color: headerPrimaryColor),
          ),
          _buildDrawerItem(
            icon: Icons.info_outline, text: l10n.aboutUs,
            onTap: () => _navigateTo(context, AboutUsScreen.routeName),
            textColor: itemTextColor, iconColor: itemIconColor,
          ),
          _buildDrawerItem(
            icon: Icons.star_border_purple500_outlined, text: l10n.testimonials,
            onTap: () => _navigateTo(context, TestimonialsScreen.routeName),
            textColor: itemTextColor, iconColor: itemIconColor,
          ),
          ExpansionTile(
            leading: Icon(Icons.language, color: itemIconColor, size: 22),
            title: Text(l10n.changeLanguage, style: TextStyle(color: itemTextColor, fontSize: 14.5)),
            iconColor: itemIconColor, collapsedIconColor: itemIconColor,
            childrenPadding: const EdgeInsets.only(left: 16.0),
            children: <Widget>[
              _buildDrawerSubItem(context: context, text: l10n.english, textColor: itemTextColor, onTap: () { localeProvider.setLocale(const Locale('en')); Navigator.of(context).pop(); }),
              _buildDrawerSubItem(context: context, text: l10n.amharic, textColor: itemTextColor, onTap: () { localeProvider.setLocale(const Locale('am')); Navigator.of(context).pop(); }),
              _buildDrawerSubItem(context: context, text: l10n.afaanOromo, textColor: itemTextColor, onTap: () { localeProvider.setLocale(const Locale('or')); Navigator.of(context).pop(); }),
            ],
          ),
          Divider(color: Theme.of(context).dividerColor),
          _buildDrawerItem(
            icon: Icons.app_registration, text: l10n.registerforcourses,
            textColor: itemTextColor, iconColor: itemIconColor,
            onTap: () { Navigator.of(context).pop(); Navigator.of(context).push(MaterialPageRoute(builder: (_) => const RegistrationScreen())); },
          ),
          _buildDrawerItem(
            icon: Icons.school_outlined,
            text: l10n.mycourses,
            textColor: itemTextColor,
            iconColor: itemIconColor,
            onTap: () => _showNotImplemented(context, l10n.mycourses), // Now defined
          ),
          _buildDrawerItem(
            icon: Icons.assignment_turned_in_outlined,
            text: l10n.weeklyexam,
            textColor: itemTextColor,
            iconColor: itemIconColor,
            onTap: () => _showNotImplemented(context, l10n.weeklyexam), // Now defined
          ),
          Divider(color: Theme.of(context).dividerColor),
          _buildDrawerItem(
            icon: Icons.share_outlined,
            text: l10n.sharetheapp,
            textColor: itemTextColor,
            iconColor: itemIconColor,
            onTap: () => _shareApp(context),
          ),
          _buildDrawerItem(
            icon: Icons.telegram,
            text: l10n.joinourtelegram,
            textColor: itemTextColor,
            iconColor: itemIconColor,
            onTap: () {
              Navigator.of(context).pop();
              _launchUrl(context, _telegramChannelUrl);
            },
          ),
          _buildDrawerItem(
            icon: Icons.forum_outlined, text: l10n.discussiongroup,
            textColor: itemTextColor, iconColor: itemIconColor,
            onTap: () => _navigateTo(context, DiscussionGroupScreen.routeName),
          ),
          Divider(color: Theme.of(context).dividerColor),
          _buildDrawerItem(
            icon: Icons.refresh_outlined, text: l10n.refresh,
            textColor: itemTextColor, iconColor: itemIconColor,
            onTap: () => _handleRefresh(context),
          ),
          _buildDrawerItem(
            icon: Icons.contact_phone_outlined,
            text: l10n.contactus,
            textColor: itemTextColor,
            iconColor: itemIconColor,
            onTap: () => _showContactOptions(context),
          ),
          _buildDrawerItem(
            icon: Icons.settings_outlined, text: l10n.settings,
            textColor: itemTextColor, iconColor: itemIconColor,
            onTap: () => _navigateTo(context, SettingsScreen.routeName),
          ),
          Divider(color: Theme.of(context).dividerColor),
          if (authProvider.currentUser != null)
            _buildDrawerItem(
              icon: Icons.logout, text: l10n.logout,
              onTap: () => _handleLogout(context, authProvider),
              textColor: Theme.of(context).colorScheme.error,
              iconColor: Theme.of(context).colorScheme.error,
            ),
        ],
      ),
    );
  }

  Widget _buildDrawerItem({
    required IconData icon,
    required String text,
    required GestureTapCallback onTap,
    Color? textColor,
    Color? iconColor,
  }) {
    return ListTile(
      leading: Icon(icon, color: iconColor, size: 22),
      title: Text(text, style: TextStyle(color: textColor, fontSize: 14.5)),
      onTap: onTap,
      dense: true,
      visualDensity: VisualDensity.compact,
    );
  }

  Widget _buildDrawerSubItem({
    required BuildContext context,
    required String text,
    required GestureTapCallback onTap,
    Color? textColor,
  }) {
    return ListTile(
      contentPadding: const EdgeInsets.only(left: 56.0),
      title: Text(text, style: TextStyle(color: textColor, fontSize: 14)),
      onTap: onTap,
      dense: true,
      visualDensity: VisualDensity.compact,
    );
  }
}
// lib/widgets/password_form_field.dart
import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class PasswordFormField extends StatelessWidget {
  final TextEditingController controller;
  final bool isPasswordVisible;
  final VoidCallback onToggleVisibility;
  final String? labelText;
  final String? hintText;
  final FormFieldValidator<String>? validator;
  final AppLocalizations l10n;

  const PasswordFormField({
    super.key,
    required this.controller,
    required this.isPasswordVisible,
    required this.onToggleVisibility,
    this.labelText,
    this.hintText,
    this.validator,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: controller,
      decoration: InputDecoration(
        labelText: labelText ?? l10n.passwordLabel,
        hintText: hintText ?? l10n.passwordHint,
        suffixIcon: IconButton(
          icon: Icon(
            isPasswordVisible ? Icons.visibility_off : Icons.visibility,
            color: Colors.grey[600],
          ),
          onPressed: onToggleVisibility,
        ),
        border: const OutlineInputBorder(),
        contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 14.0),
      ),
      obscureText: !isPasswordVisible,
      validator: validator ?? (value) {
        if (value == null || value.isEmpty) {
          return l10n.passwordValidationErrorRequired;
        }
        if (value.length < 6) {
          return l10n.passwordValidationErrorLength;
        }
        return null;
      },
    );
  }
}
// lib/widgets/phone_form_field.dart
import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class PhoneFormField extends StatelessWidget {
  final TextEditingController controller;
  final String? labelText; // Make label optional or use l10n directly
  final String? hintText;  // Make hint optional or use l10n directly
  final FormFieldValidator<String>? validator;
  final AppLocalizations l10n; // To access localized strings

  const PhoneFormField({
    super.key,
    required this.controller,
    this.labelText,
    this.hintText,
    this.validator,
    required this.l10n, // Pass AppLocalizations instance
  });

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: controller,
      decoration: InputDecoration(
        labelText: labelText ?? l10n.phoneNumberLabel,
        hintText: hintText ?? l10n.phoneNumberHint,
        prefixIcon: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 14.0),
          child: Text(
            '+251 ', // Or make this configurable if needed
            style: TextStyle(fontSize: 16, color: Colors.grey[700]),
          ),
        ),
        border: const OutlineInputBorder(), // Ensure border is consistent
        contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 14.0),
      ),
      keyboardType: TextInputType.phone,
      validator: validator ?? (value) { // Default validator using l10n
        if (value == null || value.isEmpty) {
          return l10n.phoneNumberValidationErrorRequired;
        }
        if (!RegExp(r'^[0-9]{9}$').hasMatch(value)) { // Assumes 9 digits after +251
          return l10n.phoneNumberValidationErrorInvalid;
        }
        return null;
      },
    );
  }
}
--------------
//lib
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

// Providers
import 'package:mgw_tutorial/provider/discussion_provider.dart';
import 'package:mgw_tutorial/provider/auth_provider.dart';
import 'package:mgw_tutorial/provider/department_provider.dart';
import 'package:mgw_tutorial/provider/locale_provider.dart';
import 'package:mgw_tutorial/provider/semester_provider.dart';
import 'package:mgw_tutorial/provider/api_course_provider.dart';
import 'package:mgw_tutorial/provider/section_provider.dart';
import 'package:mgw_tutorial/provider/lesson_provider.dart';
import 'package:mgw_tutorial/provider/theme_provider.dart';
import 'package:mgw_tutorial/provider/testimonial_provider.dart';
import 'package:mgw_tutorial/provider/order_provider.dart';


// Screens
import 'package:mgw_tutorial/screens/main_screen.dart';
import 'package:mgw_tutorial/screens/auth/login_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/about_us_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/settings_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/discussion_group_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/create_post_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/post_detail_screen.dart';
import 'package:mgw_tutorial/screens/library/course_sections_screen.dart';
import 'package:mgw_tutorial/screens/library/lesson_list_screen.dart';
import 'package:mgw_tutorial/screens/sidebar/testimonials_screen.dart';

// Models
import 'package:mgw_tutorial/models/post.dart';
import 'package:mgw_tutorial/models/api_course.dart';
import 'package:mgw_tutorial/models/section.dart'; // <<< ADDED THIS IMPORT

// Localization
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => LocaleProvider()),
        ChangeNotifierProvider(create: (context) => ThemeProvider()),
        ChangeNotifierProvider(create: (context) => SemesterProvider()),
        ChangeNotifierProvider(create: (context) => AuthProvider()),
        ChangeNotifierProvider(create: (context) => DepartmentProvider()),
        ChangeNotifierProvider(create: (context) => ApiCourseProvider()),
        ChangeNotifierProvider(create: (context) => SectionProvider()),
        ChangeNotifierProvider(create: (context) => LessonProvider()),
        ChangeNotifierProvider(create: (context) => TestimonialProvider()),
        ChangeNotifierProvider(create: (context) => OrderProvider()),
        ChangeNotifierProxyProvider<AuthProvider, DiscussionProvider>(
          create: (context) => DiscussionProvider(
            Provider.of<AuthProvider>(context, listen: false),
          ),
          update: (context, auth, previousDiscussionProvider) =>
              DiscussionProvider(auth),
        ),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  TextTheme _poppinsTextTheme(TextTheme base) {
    return base.copyWith(
      displayLarge: base.displayLarge?.copyWith(fontFamily: 'Poppins'),
      displayMedium: base.displayMedium?.copyWith(fontFamily: 'Poppins'),
      displaySmall: base.displaySmall?.copyWith(fontFamily: 'Poppins'),
      headlineLarge: base.headlineLarge?.copyWith(fontFamily: 'Poppins'),
      headlineMedium: base.headlineMedium?.copyWith(fontFamily: 'Poppins'),
      headlineSmall: base.headlineSmall?.copyWith(fontFamily: 'Poppins'),
      titleLarge: base.titleLarge?.copyWith(fontFamily: 'Poppins'),
      titleMedium: base.titleMedium?.copyWith(fontFamily: 'Poppins'),
      titleSmall: base.titleSmall?.copyWith(fontFamily: 'Poppins'),
      bodyLarge: base.bodyLarge?.copyWith(fontFamily: 'Poppins'),
      bodyMedium: base.bodyMedium?.copyWith(fontFamily: 'Poppins'),
      bodySmall: base.bodySmall?.copyWith(fontFamily: 'Poppins'),
      labelLarge: base.labelLarge?.copyWith(fontFamily: 'Poppins'),
      labelMedium: base.labelMedium?.copyWith(fontFamily: 'Poppins'),
      labelSmall: base.labelSmall?.copyWith(fontFamily: 'Poppins'),
    );
  }

  @override
  Widget build(BuildContext context) {
    final localeProvider = Provider.of<LocaleProvider>(context);
    final themeProvider = Provider.of<ThemeProvider>(context);

    final TextTheme typographyLight = _poppinsTextTheme(Typography.material2021(platform: TargetPlatform.android).black);
    final TextTheme typographyDark = _poppinsTextTheme(Typography.material2021(platform: TargetPlatform.android).white);

    return MaterialApp(
      title: 'MGW Tutorial',
      themeMode: themeProvider.themeMode,
      theme: ThemeData( // Light Theme
        primarySwatch: Colors.blue,
        brightness: Brightness.light,
        fontFamily: 'Poppins',
        scaffoldBackgroundColor: const Color(0xFFE3E8FF),
        colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.blue, brightness: Brightness.light).copyWith(
          secondary: Colors.blueAccent,
          surface: Colors.white,
          onSurface: Colors.black87,
          primary: Colors.blue[700],
          onPrimary: Colors.white,
          surfaceVariant: Colors.grey.shade200, // For subtle backgrounds like image error
          onSurfaceVariant: Colors.grey.shade700, // Text/icons on surfaceVariant
          primaryContainer: Colors.blue.shade100, // Lighter variant of primary
          onPrimaryContainer: Colors.blue.shade900, // Text on primaryContainer
        ),
        appBarTheme: AppBarTheme(
          backgroundColor: Colors.white,
          elevation: 1.0,
          iconTheme: const IconThemeData(color: Colors.black),
          actionsIconTheme: const IconThemeData(color: Colors.black),
          titleTextStyle: typographyLight.titleLarge?.copyWith(
            color: Colors.black,
            fontSize: 20,
            fontWeight: FontWeight.w500,
          ),
          systemOverlayStyle: SystemUiOverlayStyle.dark.copyWith(
            statusBarColor: Colors.transparent,
            statusBarIconBrightness: Brightness.dark,
            statusBarBrightness: Brightness.light,
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.blue[700],
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            textStyle: typographyLight.labelLarge?.copyWith(fontSize: 16, fontWeight: FontWeight.bold),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: BorderSide(color: Colors.grey[400]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: BorderSide(color: Colors.grey[400]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: BorderSide(color: Colors.blue[700]!),
          ),
          filled: true,
          fillColor: Colors.white,
          contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0),
        ),
        cardTheme: CardTheme(
          elevation: 4.0,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
          margin: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 0),
          color: Colors.white,
        ),
         bottomNavigationBarTheme: BottomNavigationBarThemeData(
          backgroundColor: Colors.white,
          selectedItemColor: Colors.blue[700],
          unselectedItemColor: Colors.grey[600],
          type: BottomNavigationBarType.fixed,
          showUnselectedLabels: true,
        ),
        drawerTheme: const DrawerThemeData(
          backgroundColor: Colors.white,
        ),
        listTileTheme: ListTileThemeData(
          iconColor: Colors.black54,
          textColor: typographyLight.bodyLarge?.color,
        ),
        dividerColor: Colors.grey[300],
        iconTheme: IconThemeData(color: Colors.grey[700]),
        textTheme: typographyLight.copyWith(
          titleLarge: typographyLight.titleLarge?.copyWith(fontWeight: FontWeight.bold, color: Colors.black87, fontSize: 20),
          titleMedium: typographyLight.titleMedium?.copyWith(fontWeight: FontWeight.w500, color: Colors.black87, fontSize: 18),
          titleSmall: typographyLight.titleSmall?.copyWith(fontWeight: FontWeight.w500, color: Colors.black87, fontSize: 16),
        ),
        chipTheme: ChipThemeData(
          backgroundColor: Colors.blue[700],
          labelStyle: typographyLight.bodySmall?.copyWith(color: Colors.white, fontWeight: FontWeight.bold),
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
        ),
      ),
      darkTheme: ThemeData( 
        primarySwatch: Colors.blue,
        brightness: Brightness.dark,
        fontFamily: 'Poppins',
        scaffoldBackgroundColor: const Color(0xFF121212),
        colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.blue, brightness: Brightness.dark).copyWith(
          secondary: Colors.tealAccent[200],
          surface: const Color(0xFF1E1E1E),
          onSurface: Colors.white.withOpacity(0.87),
          primary: Colors.lightBlue[300],
          onPrimary: Colors.black,
          surfaceVariant: Colors.grey.shade800, // For subtle backgrounds like image error in dark
          onSurfaceVariant: Colors.grey.shade400, // Text/icons on surfaceVariant in dark
          primaryContainer: Colors.blue.shade800, // Darker variant of primary for containers
          onPrimaryContainer: Colors.blue.shade100, // Text on primaryContainer in dark
        ),
        appBarTheme: AppBarTheme(
          backgroundColor: const Color(0xFF1F1F1F),
          elevation: 1.0,
          iconTheme: const IconThemeData(color: Colors.white),
          actionsIconTheme: const IconThemeData(color: Colors.white),
          titleTextStyle: typographyDark.titleLarge?.copyWith(
            color: Colors.white,
            fontSize: 20,
            fontWeight: FontWeight.w500,
          ),
          systemOverlayStyle: SystemUiOverlayStyle.light.copyWith(
            statusBarColor: Colors.transparent,
            statusBarIconBrightness: Brightness.light,
            statusBarBrightness: Brightness.dark,
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.lightBlue[400],
            foregroundColor: Colors.black,
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            textStyle: typographyDark.labelLarge?.copyWith(fontSize: 16, fontWeight: FontWeight.bold),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: BorderSide(color: Colors.lightBlue[300]!),
          ),
          filled: true,
          fillColor: const Color(0xFF2C2C2C),
          hintStyle: TextStyle(color: Colors.grey[500]),
          labelStyle: TextStyle(color: Colors.grey[400]),
          contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0),
        ),
        cardTheme: CardTheme(
          elevation: 4.0,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
          margin: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 0),
          color: const Color(0xFF1E1E1E),
        ),
         bottomNavigationBarTheme: BottomNavigationBarThemeData(
          backgroundColor: const Color(0xFF1F1F1F),
          selectedItemColor: Colors.white,
          unselectedItemColor: Colors.grey[500],
          type: BottomNavigationBarType.fixed,
          showUnselectedLabels: true,
        ),
        drawerTheme: const DrawerThemeData(
          backgroundColor: Color(0xFF212121),
        ),
        listTileTheme: ListTileThemeData(
          iconColor: Colors.white70,
          textColor: typographyDark.bodyLarge?.color,
        ),
        dividerColor: Colors.grey[800],
        iconTheme: IconThemeData(color: Colors.grey[400]),
        textTheme: typographyDark.copyWith(
          titleLarge: typographyDark.titleLarge?.copyWith(color: Colors.white.withOpacity(0.95), fontWeight: FontWeight.bold, fontSize: 20),
          titleMedium: typographyDark.titleMedium?.copyWith(color: Colors.white.withOpacity(0.90), fontWeight: FontWeight.w500, fontSize: 18), // Adjusted weight for consistency
          titleSmall: typographyDark.titleSmall?.copyWith(color: Colors.white.withOpacity(0.87), fontWeight: FontWeight.w500, fontSize: 16), // Adjusted weight
        ),
        popupMenuTheme: PopupMenuThemeData(color: const Color(0xFF2C2C2C)),
        dialogBackgroundColor: const Color(0xFF1E1E1E),
        chipTheme: ChipThemeData(
          backgroundColor: Colors.blueGrey[700],
          labelStyle: typographyDark.bodySmall?.copyWith(color: Colors.white.withOpacity(0.87), fontWeight: FontWeight.bold),
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
        ),
      ),
      debugShowCheckedModeBanner: false,
      locale: localeProvider.locale,
      localizationsDelegates: const [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', ''),
        Locale('am', ''),
        Locale('or', ''),
      ],
      home: const LoginScreen(),
      routes: {
        '/main': (ctx) => const MainScreen(),
        '/login': (ctx) => const LoginScreen(),
        AboutUsScreen.routeName: (ctx) => const AboutUsScreen(),
        SettingsScreen.routeName: (ctx) => const SettingsScreen(),
        DiscussionGroupScreen.routeName: (ctx) => const DiscussionGroupScreen(),
        CreatePostScreen.routeName: (ctx) => const CreatePostScreen(),
        TestimonialsScreen.routeName: (ctx) => const TestimonialsScreen(),
        PostDetailScreen.routeName: (ctx) {
          final args = ModalRoute.of(ctx)?.settings.arguments;
          if (args is Post) {
            return PostDetailScreen(post: args);
          }
          return Scaffold(appBar: AppBar(title: const Text("Error")), body: const Center(child: Text("Error: Invalid post data passed to PostDetailScreen.")));
        },
        CourseSectionsScreen.routeName: (ctx) {
          final args = ModalRoute.of(ctx)?.settings.arguments;
          if (args is ApiCourse) {
            return CourseSectionsScreen(course: args);
          }
          return Scaffold(appBar: AppBar(title: const Text("Error")), body: const Center(child: Text("Error: Invalid course data passed to CourseSectionsScreen.")));
        },
        // <<< THIS IS THE CORRECTED ROUTE DEFINITION >>>
        LessonListScreen.routeName: (ctx) {
          final args = ModalRoute.of(ctx)?.settings.arguments;
          if (args is Section) { // Expects a Section object
            return LessonListScreen(section: args);
          }
          // Fallback if the argument is not a Section object
          return Scaffold(
              appBar: AppBar(title: const Text("Error")),
              body: const Center(child: Text("Error: Invalid data type for Lesson List. Expected Section.")));
        },
      },
    );
  }
}